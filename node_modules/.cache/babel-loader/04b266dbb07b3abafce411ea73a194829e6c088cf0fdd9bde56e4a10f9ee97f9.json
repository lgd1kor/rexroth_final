{"ast":null,"code":"import { r as registerInstance, h, g as getElement } from './index-f45b2301.js';\nconst dcUiAnchorBarCss = \":root{--White-Gradient:linear-gradient(\\n    180deg,\\n    rgba(255, 255, 255, 0) 0%,\\n    rgba(255, 255, 255, 0.5) 60%,\\n    #ffffff 100%\\n  );--Grey-Gradient:linear-gradient(\\n    180deg,\\n    rgba(237, 241, 244, 0) 0%,\\n    rgba(237, 241, 244, 0.5) 60%,\\n    #edf1f4 100%\\n  );--Blue-Gradient:linear-gradient(\\n    180deg,\\n    rgba(0, 43, 73, 0) 0%,\\n    rgba(0, 43, 73, 0.5) 60%,\\n    #002b49 100%\\n  )}:host{--anchor-bar-max-width:1920px}@media (max-width: 1920px){:host{--anchor-bar-max-width:1440px}}.dc-ui-anchor-bar{background-color:#ffffff;position:relative;transition:top 0.3s ease-in-out;display:flex}.dc-ui-anchor-bar:before{content:\\\"\\\";position:absolute;bottom:0;left:0;right:0;width:100%;height:1px;background-color:#a3bac8;z-index:1}.dc-ui-anchor-bar--is-sticky{position:fixed;top:var(--header-offset-height, 0);left:0;right:0;z-index:1000;max-width:var(--anchor-bar-max-width);margin:0 auto;box-shadow:0px 16px 32px -16px rgba(0, 43, 73, 0.32)}.dc-ui-anchor-bar--is-sticky:before{bottom:unset;top:0;background-color:#edf1f4}.dc-ui-anchor-bar__inner{display:grid;grid-template-columns:1fr;align-items:center;margin:0 auto;max-width:1170px;height:48px;width:100%}.dc-ui-anchor-bar__inner--has-overflow{padding-inline:15px;grid-template-columns:auto 1fr auto;gap:12px}.dc-ui-anchor-bar__inner-wrapper{display:flex;gap:12px;max-width:100%;margin:0 auto;overflow-x:auto}.dc-ui-anchor-bar__inner-wrapper::-webkit-scrollbar{display:none}\";\nconst DcUiAnchorBarStyle0 = dcUiAnchorBarCss;\nconst DcUiAnchorBar = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.anchorItems = [];\n    this.sections = [];\n    // State tracking\n    this.currentIndex = -1;\n    this.lastScrollPosition = window.scrollY;\n    this.isScrollingUp = false;\n    this.lastKnownScrollPosition = 0;\n    this.isShadowRoot = false;\n    this.sectionsMap = new Map();\n    // Layout constants\n    this.LAYOUT = {\n      INLINE_PADDING: 15,\n      OVERFLOW_BUTTON_WIDTH: 32,\n      OVERFLOW_BUTTON_GAP: 12,\n      ITEM_GAP: 12\n    };\n    // Move click handler to class method for proper cleanup\n    this.handleAnchorClick = e => {\n      e.preventDefault();\n      const item = e.currentTarget;\n      const href = item.getAttribute('href');\n      this.scrollToSection(href);\n    };\n    this.setScrollDirection = () => {\n      const currentScrollPosition = window.scrollY;\n      const wasScrollingUp = this.isScrollingUp;\n      this.isScrollingUp = currentScrollPosition < this.lastScrollPosition;\n      this.lastScrollPosition = currentScrollPosition;\n      // Check if scroll direction changed and update offset if sticky\n      if (wasScrollingUp !== this.isScrollingUp && this.isAnchorBarSticky) {\n        this.updateStickyOffset(this.isScrollingUp);\n      }\n    };\n    this.handleScroll = () => {\n      this.lastKnownScrollPosition = window.scrollY;\n      requestAnimationFrame(() => {\n        setTimeout(() => {\n          if (this.lastKnownScrollPosition === window.scrollY) {\n            this.updateActiveSection();\n          }\n        }, 150);\n      });\n    };\n    this.updateActiveSection = () => {\n      // Skip updating active section if not sticky\n      if (!this.isAnchorBarSticky) {\n        this.currentIndex = -1;\n        this.toggleActiveAnchor(-1);\n        return;\n      }\n      const activeSection = this.getActiveSection();\n      this.currentIndex = activeSection;\n      this.toggleActiveAnchor(activeSection);\n    };\n    this.getActiveSection = () => {\n      const headerOffset = this.isHeaderShown ? this.getHeaderHeight() + this.getAnchorBarHeight() : this.getAnchorBarHeight();\n      const currentPosition = window.scrollY + headerOffset;\n      let activeSection = null;\n      for (let i = this.sections.length - 1; i >= 0 && activeSection === null; i--) {\n        if (currentPosition >= this.getElementPosition(i)) {\n          activeSection = i;\n        }\n      }\n      return activeSection;\n    };\n    this.getElementPosition = index => {\n      const section = this.sections[index];\n      const headerOffset = this.isScrollingUp && this.isHeaderShown ? this.getHeaderHeight() : 0;\n      const anchorBarOffset = this.getAnchorBarHeight();\n      // Adjust the position calculation to account for header and anchor bar visibility\n      return section.getBoundingClientRect().top + window.scrollY - headerOffset - anchorBarOffset;\n    };\n    this.toggleActiveAnchor = index => {\n      const anchorElements = this.anchorItems;\n      for (let i = 0; i < anchorElements.length; i += 1) {\n        // Always remove attributes if not sticky or if not the active index\n        if (!this.isAnchorBarSticky || i !== index) {\n          anchorElements[i].removeAttribute('selected');\n          anchorElements[i].removeAttribute('aria-current');\n          continue;\n        }\n        // Only set attributes if sticky and is active index\n        anchorElements[i].setAttribute('selected', '');\n        anchorElements[i].setAttribute('aria-current', 'location');\n        if (i !== 0 && this.hasOverflow && this.isAnchorBarSticky) {\n          anchorElements[i].scrollIntoView({\n            behavior: 'smooth',\n            inline: 'center'\n          });\n        }\n      }\n    };\n    this.checkForOverflow = () => {\n      if (!this.anchorBarContainer) return;\n      const {\n        width: containerWidth\n      } = this.anchorBarContainer.getBoundingClientRect();\n      const {\n        INLINE_PADDING,\n        OVERFLOW_BUTTON_WIDTH,\n        OVERFLOW_BUTTON_GAP\n      } = this.LAYOUT;\n      const availableWidth = containerWidth - INLINE_PADDING * 2 - OVERFLOW_BUTTON_WIDTH * 2 - OVERFLOW_BUTTON_GAP * 2;\n      const itemsWidth = this.anchorItems.reduce((acc, item) => acc + item.getBoundingClientRect().width + this.LAYOUT.ITEM_GAP, -this.LAYOUT.ITEM_GAP // Subtract one gap since we don't need it after the last item\n      );\n      this.hasOverflow = itemsWidth > availableWidth;\n    };\n    this.scrollOffset = 0;\n    this.isAnchorBarSticky = false;\n    this.isHeaderShown = false;\n    this.hasOverflow = false;\n    this.isAtStart = true;\n    this.isAtEnd = false;\n  }\n  handleHeaderShown() {\n    this.isHeaderShown = true;\n  }\n  handleHeaderHidden() {\n    this.isHeaderShown = false;\n  }\n  handleCurrentIndexChange() {\n    this.updateButtonStates();\n  }\n  // Methods\n  async goToSectionIndex(index) {\n    this.currentIndex = index;\n    this.toggleActiveAnchor(index);\n  }\n  // Lifecycle Methods\n  componentDidLoad() {\n    const rootNode = this.el.getRootNode();\n    this.isShadowRoot = rootNode instanceof ShadowRoot;\n    this.initializeElements();\n    this.setupObservers();\n    this.setupEventListeners();\n    this.checkForOverflow();\n  }\n  disconnectedCallback() {\n    this.cleanupObservers();\n    this.cleanupEventListeners();\n  }\n  setupEventListeners() {\n    this.setupClickHandlers();\n    window.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('scroll', this.setScrollDirection);\n    window.addEventListener('resize', this.checkForOverflow);\n  }\n  cleanupEventListeners() {\n    window.removeEventListener('scroll', this.handleScroll);\n    window.removeEventListener('scroll', this.setScrollDirection);\n    window.removeEventListener('resize', this.checkForOverflow);\n    // Add cleanup for anchor item click listeners\n    this.anchorItems.forEach(item => {\n      item.removeEventListener('click', this.handleAnchorClick);\n    });\n  }\n  cleanupObservers() {\n    var _a, _b, _c;\n    (_a = this.sectionVisibilityObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n    (_b = this.anchorBarStickyObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n    (_c = this.lastSectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();\n  }\n  // Initialize Elements\n  initializeElements() {\n    // Get header reference considering shadow DOM\n    this.header = document.querySelector('dc-ui-header') || null;\n    // Get anchor items\n    this.anchorItems = Array.from(this.el.children).filter(child => child.tagName.toLowerCase() === 'dc-ui-anchor-bar-item');\n    if (this.isShadowRoot) {\n      this.sections = this.anchorItems.map(item => {\n        const root = item.getRootNode();\n        const section = root.host.shadowRoot.querySelector(item.getAttribute('href'));\n        this.sectionsMap.set(item.getAttribute('href'), section);\n        return section;\n      });\n    } else {\n      this.sections = this.anchorItems.map(item => {\n        const href = item.getAttribute('href');\n        const section = document.querySelector(href);\n        if (section) {\n          this.sectionsMap.set(href, section);\n        }\n        return section;\n      }).filter(Boolean);\n    }\n    this.updateButtonStates();\n  }\n  setupObservers() {\n    var _a;\n    // Observer for sticky behavior\n    this.anchorBarStickyObserver = new IntersectionObserver(_ref => {\n      let [entry] = _ref;\n      const shouldBeSticky = !entry.isIntersecting;\n      if (shouldBeSticky !== this.isAnchorBarSticky) {\n        this.isAnchorBarSticky = shouldBeSticky;\n        if (this.isAnchorBarSticky) {\n          this.updateStickyOffset();\n        }\n      }\n    }, {\n      threshold: 1,\n      rootMargin: '-1px 0px 0px 0px'\n    });\n    this.anchorBarStickyObserver.observe(this.el);\n    // Modified last section observer\n    const lastSection = (_a = this.sections[this.sections.length - 1]) === null || _a === void 0 ? void 0 : _a.nextElementSibling;\n    if (lastSection) {\n      this.lastSectionObserver = new IntersectionObserver(entries => {\n        const lastSectionEntry = entries[0];\n        const rect = lastSectionEntry.boundingClientRect;\n        const anchorBarHeight = this.getAnchorBarHeight();\n        if (!lastSectionEntry.isIntersecting && rect.bottom <= anchorBarHeight) {\n          // Past the bottom of all sections\n          this.isAnchorBarSticky = false;\n        } else if (lastSectionEntry.isIntersecting && this.isScrollingUp) {\n          // When scrolling back up into sections, let the anchorBarStickyObserver handle it\n          const anchorBarRect = this.el.getBoundingClientRect();\n          if (anchorBarRect.top <= 0) {\n            this.isAnchorBarSticky = true;\n            this.updateStickyOffset(true);\n          }\n        }\n      }, {\n        threshold: [0],\n        rootMargin: '0px 0px 0px 0px'\n      });\n      this.lastSectionObserver.observe(lastSection);\n    }\n  }\n  // Click Handlers\n  setupClickHandlers() {\n    this.anchorItems.forEach(item => {\n      item.addEventListener('click', this.handleAnchorClick);\n    });\n  }\n  // Helper Methods\n  getHeaderHeight() {\n    if (!this.header) return 0;\n    return this.header.getBoundingClientRect().height;\n  }\n  getAnchorBarHeight() {\n    var _a, _b;\n    return (_b = (_a = this.anchorBarContainer) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().height) !== null && _b !== void 0 ? _b : 0;\n  }\n  updateStickyOffset() {\n    let zero = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.el.style.setProperty('--header-offset-height', `${zero ? this.getHeaderHeight() : 0}px`);\n  }\n  scrollToSection(href) {\n    const section = this.sectionsMap.get(href);\n    if (!section) return;\n    const scrollDirection = this.getScrollDirection(section);\n    const headerHeight = scrollDirection === 'up' ? this.getHeaderHeight() : 0;\n    const anchorBarHeight = this.getAnchorBarHeight();\n    const safeZoneOffset = this.scrollOffset;\n    const totalOffset = headerHeight + anchorBarHeight + (this.isAnchorBarSticky ? 0 : anchorBarHeight) + safeZoneOffset;\n    // Set a CSS custom property for scroll-margin-top\n    section.style.scrollMarginTop = `${totalOffset}px`;\n    section.scrollIntoView({\n      behavior: 'smooth',\n      block: 'start'\n    });\n    // remove scroll-margin-top\n    section.style.removeProperty('scroll-margin-top');\n    // Update URL without scroll\n    history.pushState(null, '', href);\n  }\n  getScrollDirection(targetSection) {\n    const currentSection = this.currentIndex !== -1 ? this.sections[this.currentIndex] : null;\n    if (!currentSection) {\n      return targetSection.getBoundingClientRect().top > window.innerHeight / 2 ? 'down' : 'up';\n    }\n    return targetSection.getBoundingClientRect().top < currentSection.getBoundingClientRect().top ? 'up' : 'down';\n  }\n  handleOverflowButtonClick(direction) {\n    const nextIndex = direction === 'left' ? Math.max(0, this.currentIndex - 1) : Math.min(this.anchorItems.length - 1, this.currentIndex + 1);\n    if (nextIndex !== this.currentIndex) {\n      this.scrollToSection(this.anchorItems[nextIndex].getAttribute('href'));\n    }\n  }\n  updateButtonStates() {\n    this.isAtStart = this.currentIndex <= 0;\n    this.isAtEnd = this.currentIndex >= this.anchorItems.length - 1;\n  }\n  // Render\n  render() {\n    const overflowButtonLeft = h(\"dc-ui-button\", {\n      key: 'f7394f90139b5900871d5ecd1773abc5a370f1dc',\n      icon: \"dc_backward_left\",\n      variant: \"link\",\n      size: \"small\",\n      \"hide-label\": \"true\",\n      disabled: this.isAtStart,\n      onClick: () => this.handleOverflowButtonClick('left')\n    }, \"Go to previous section\");\n    const overflowButtonRight = h(\"dc-ui-button\", {\n      key: '29db7b7c5507539fb02a668ac99ca06450002ce4',\n      icon: \"dc_forward_right\",\n      variant: \"link\",\n      size: \"small\",\n      \"hide-label\": \"true\",\n      disabled: this.isAtEnd,\n      onClick: () => this.handleOverflowButtonClick('right')\n    }, \"Go to next section\");\n    return h(\"div\", {\n      key: '9e225fe33d5ba2089adbfc1a3b715f6ff082e454',\n      class: {\n        'dc-ui-anchor-bar': true,\n        'dc-ui-anchor-bar--is-sticky': this.isAnchorBarSticky\n      }\n    }, h(\"div\", {\n      key: '351805c4ffaf07fb8faf3d69394ff2d908592350',\n      class: {\n        'dc-ui-anchor-bar__inner': true,\n        'dc-ui-anchor-bar__inner--has-overflow': this.hasOverflow\n      },\n      ref: el => this.anchorBarContainer = el\n    }, this.hasOverflow && overflowButtonLeft, h(\"nav\", {\n      key: 'c0fa94be54ba234a8cbe38e55b7ef0438ca9c7ec',\n      class: \"dc-ui-anchor-bar__inner-wrapper\"\n    }, h(\"slot\", {\n      key: '9120a05e7c3965c0c8e83a398c6b1fef00fd68d0'\n    })), this.hasOverflow && overflowButtonRight));\n  }\n  get el() {\n    return getElement(this);\n  }\n  static get watchers() {\n    return {\n      \"currentIndex\": [\"handleCurrentIndexChange\"]\n    };\n  }\n};\nDcUiAnchorBar.style = DcUiAnchorBarStyle0;\nexport { DcUiAnchorBar as dc_ui_anchor_bar };","map":{"version":3,"names":["dcUiAnchorBarCss","DcUiAnchorBarStyle0","DcUiAnchorBar","anchorItems","sections","currentIndex","lastScrollPosition","window","scrollY","isScrollingUp","lastKnownScrollPosition","isShadowRoot","sectionsMap","Map","LAYOUT","INLINE_PADDING","OVERFLOW_BUTTON_WIDTH","OVERFLOW_BUTTON_GAP","ITEM_GAP","handleAnchorClick","e","preventDefault","item","currentTarget","href","getAttribute","scrollToSection","setScrollDirection","currentScrollPosition","wasScrollingUp","isAnchorBarSticky","updateStickyOffset","handleScroll","requestAnimationFrame","setTimeout","updateActiveSection","toggleActiveAnchor","activeSection","getActiveSection","headerOffset","isHeaderShown","getHeaderHeight","getAnchorBarHeight","currentPosition","i","length","getElementPosition","index","section","anchorBarOffset","getBoundingClientRect","top","anchorElements","removeAttribute","setAttribute","hasOverflow","scrollIntoView","behavior","inline","checkForOverflow","anchorBarContainer","width","containerWidth","availableWidth","itemsWidth","reduce","acc","handleHeaderShown","handleHeaderHidden","handleCurrentIndexChange","updateButtonStates","goToSectionIndex","componentDidLoad","rootNode","el","getRootNode","ShadowRoot","initializeElements","setupObservers","setupEventListeners","disconnectedCallback","cleanupObservers","cleanupEventListeners","setupClickHandlers","addEventListener","removeEventListener","forEach","_a","sectionVisibilityObserver","disconnect","_b","anchorBarStickyObserver","_c","lastSectionObserver","header","document","querySelector","Array","from","children","filter","child","tagName","toLowerCase","map","root","host","shadowRoot","set","Boolean","IntersectionObserver","_ref","entry","shouldBeSticky","isIntersecting","threshold","rootMargin","observe","lastSection","nextElementSibling","entries","lastSectionEntry","rect","boundingClientRect","anchorBarHeight","bottom","anchorBarRect","height","zero","arguments","undefined","style","setProperty","get","scrollDirection","getScrollDirection","headerHeight","safeZoneOffset","scrollOffset","totalOffset","scrollMarginTop","block","removeProperty","history","pushState","targetSection","currentSection","innerHeight","handleOverflowButtonClick","direction","nextIndex","Math","max","min","isAtStart","isAtEnd","render","overflowButtonLeft","h","key","icon","variant","size","disabled","onClick","overflowButtonRight","class","ref"],"sources":["C:\\Users\\LGD1KOR\\Desktop\\rexroth_products_with_versions\\rexroth_final\\node_modules\\@boschrexroth\\nextgen-web-ui-toolkit\\dist\\esm\\src\\components\\dc-ui-anchor-bar\\dc-ui-anchor-bar.scss?tag=dc-ui-anchor-bar&encapsulation=shadow","C:\\Users\\LGD1KOR\\Desktop\\rexroth_products_with_versions\\rexroth_final\\node_modules\\@boschrexroth\\nextgen-web-ui-toolkit\\dist\\esm\\src\\components\\dc-ui-anchor-bar\\dc-ui-anchor-bar.tsx"],"sourcesContent":[":host {\r\n  --anchor-bar-max-width: 1920px;\r\n\r\n  @include media-max('xxl', false) {\r\n    --anchor-bar-max-width: 1440px;\r\n  }\r\n}\r\n\r\n.dc-ui-anchor-bar {\r\n  background-color: $color-white;\r\n  position: relative;\r\n  transition: top 0.3s ease-in-out;\r\n  display: flex;\r\n\r\n  &:before {\r\n    content: '';\r\n    position: absolute;\r\n    bottom: 0;\r\n    left: 0;\r\n    right: 0;\r\n    width: 100%;\r\n    height: 1px;\r\n    background-color: $color-grey-03;\r\n    z-index: 1;\r\n  }\r\n\r\n  &--is-sticky {\r\n    position: fixed;\r\n    top: var(--header-offset-height, 0);\r\n    left: 0;\r\n    right: 0;\r\n    z-index: 1000;\r\n    max-width: var(--anchor-bar-max-width);\r\n    margin: 0 auto;\r\n    box-shadow: 0px 16px 32px -16px rgba(0, 43, 73, 0.32);\r\n\r\n    &:before {\r\n      bottom: unset;\r\n      top: 0;\r\n      background-color: $color-grey-01;\r\n    }\r\n  }\r\n\r\n  &__inner {\r\n    display: grid;\r\n    grid-template-columns: 1fr;\r\n    align-items: center;\r\n    margin: 0 auto;\r\n    max-width: 1170px;\r\n    height: 48px;\r\n    width: 100%;\r\n\r\n    &--has-overflow {\r\n      padding-inline: 15px;\r\n      grid-template-columns: auto 1fr auto;\r\n      gap: 12px;\r\n    }\r\n  }\r\n\r\n  &__inner-wrapper {\r\n    display: flex;\r\n    gap: 12px;\r\n    max-width: 100%;\r\n    margin: 0 auto;\r\n    overflow-x: auto;\r\n    // Hide scrollbar\r\n    &::-webkit-scrollbar {\r\n      display: none;\r\n    }\r\n  }\r\n}\r\n","import { Component, h, Element, State, Watch, Listen, Method, Prop } from '@stencil/core';\r\n\r\n@Component({\r\n  tag: 'dc-ui-anchor-bar',\r\n  styleUrl: 'dc-ui-anchor-bar.scss',\r\n  shadow: true,\r\n})\r\nexport class DcUiAnchorBar {\r\n  @Element() el: HTMLElement;\r\n  @Prop() scrollOffset: number = 0;\r\n  @State() isAnchorBarSticky: boolean = false;\r\n  @State() isHeaderShown: boolean = false;\r\n  @State() hasOverflow: boolean = false;\r\n  @State() isAtStart: boolean = true;\r\n  @State() isAtEnd: boolean = false;\r\n\r\n  // DOM Elements\r\n  private header: HTMLElement;\r\n  private anchorBarContainer: HTMLElement;\r\n  private anchorItems: HTMLElement[] = [];\r\n  private sections: HTMLElement[] = [];\r\n\r\n  // Observers\r\n  private sectionVisibilityObserver: IntersectionObserver;\r\n  private anchorBarStickyObserver: IntersectionObserver;\r\n  private lastSectionObserver: IntersectionObserver;\r\n\r\n  // State tracking\r\n  private currentIndex: number = -1;\r\n  private lastScrollPosition: number = window.scrollY;\r\n  private isScrollingUp: boolean = false;\r\n  private lastKnownScrollPosition: number = 0;\r\n  private isShadowRoot: boolean = false;\r\n\r\n  private sectionsMap: Map<string, HTMLElement> = new Map();\r\n\r\n  // Layout constants\r\n  private readonly LAYOUT = {\r\n    INLINE_PADDING: 15,\r\n    OVERFLOW_BUTTON_WIDTH: 32,\r\n    OVERFLOW_BUTTON_GAP: 12,\r\n    ITEM_GAP: 12,\r\n  } as const;\r\n\r\n  @Listen('dcHeaderShown', { target: 'window' })\r\n  handleHeaderShown() {\r\n    this.isHeaderShown = true;\r\n  }\r\n\r\n  @Listen('dcHeaderHidden', { target: 'window' })\r\n  handleHeaderHidden() {\r\n    this.isHeaderShown = false;\r\n  }\r\n\r\n  @Watch('currentIndex')\r\n  handleCurrentIndexChange() {\r\n    this.updateButtonStates();\r\n  }\r\n\r\n  // Methods\r\n  @Method()\r\n  async goToSectionIndex(index: number) {\r\n    this.currentIndex = index;\r\n    this.toggleActiveAnchor(index);\r\n  }\r\n\r\n  // Lifecycle Methods\r\n  componentDidLoad() {\r\n    const rootNode = this.el.getRootNode() as Document | ShadowRoot;\r\n    this.isShadowRoot = rootNode instanceof ShadowRoot;\r\n\r\n    this.initializeElements();\r\n    this.setupObservers();\r\n    this.setupEventListeners();\r\n    this.checkForOverflow();\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.cleanupObservers();\r\n    this.cleanupEventListeners();\r\n  }\r\n\r\n  private setupEventListeners() {\r\n    this.setupClickHandlers();\r\n    window.addEventListener('scroll', this.handleScroll);\r\n    window.addEventListener('scroll', this.setScrollDirection);\r\n    window.addEventListener('resize', this.checkForOverflow);\r\n  }\r\n\r\n  private cleanupEventListeners() {\r\n    window.removeEventListener('scroll', this.handleScroll);\r\n    window.removeEventListener('scroll', this.setScrollDirection);\r\n    window.removeEventListener('resize', this.checkForOverflow);\r\n\r\n    // Add cleanup for anchor item click listeners\r\n    this.anchorItems.forEach((item) => {\r\n      item.removeEventListener('click', this.handleAnchorClick);\r\n    });\r\n  }\r\n\r\n  private cleanupObservers() {\r\n    this.sectionVisibilityObserver?.disconnect();\r\n    this.anchorBarStickyObserver?.disconnect();\r\n    this.lastSectionObserver?.disconnect();\r\n  }\r\n\r\n  // Initialize Elements\r\n  private initializeElements() {\r\n    // Get header reference considering shadow DOM\r\n    this.header = document.querySelector('dc-ui-header') || null;\r\n\r\n    // Get anchor items\r\n    this.anchorItems = Array.from(this.el.children).filter(\r\n      (child) => child.tagName.toLowerCase() === 'dc-ui-anchor-bar-item'\r\n    ) as HTMLElement[];\r\n\r\n    if (this.isShadowRoot) {\r\n      this.sections = this.anchorItems.map((item) => {\r\n        const root = item.getRootNode() as ShadowRoot;\r\n        const section = root.host.shadowRoot.querySelector(item.getAttribute('href'));\r\n        this.sectionsMap.set(item.getAttribute('href'), section as HTMLElement);\r\n        return section as HTMLElement;\r\n      });\r\n    } else {\r\n      this.sections = this.anchorItems\r\n        .map((item) => {\r\n          const href = item.getAttribute('href');\r\n          const section = document.querySelector(href);\r\n          if (section) {\r\n            this.sectionsMap.set(href, section as HTMLElement);\r\n          }\r\n          return section;\r\n        })\r\n        .filter(Boolean) as HTMLElement[];\r\n    }\r\n\r\n    this.updateButtonStates();\r\n  }\r\n\r\n  private setupObservers() {\r\n    // Observer for sticky behavior\r\n    this.anchorBarStickyObserver = new IntersectionObserver(\r\n      ([entry]) => {\r\n        const shouldBeSticky = !entry.isIntersecting;\r\n        if (shouldBeSticky !== this.isAnchorBarSticky) {\r\n          this.isAnchorBarSticky = shouldBeSticky;\r\n          if (this.isAnchorBarSticky) {\r\n            this.updateStickyOffset();\r\n          }\r\n        }\r\n      },\r\n      {\r\n        threshold: 1,\r\n        rootMargin: '-1px 0px 0px 0px',\r\n      }\r\n    );\r\n\r\n    this.anchorBarStickyObserver.observe(this.el);\r\n\r\n    // Modified last section observer\r\n    const lastSection = this.sections[this.sections.length - 1]?.nextElementSibling;\r\n    if (lastSection) {\r\n      this.lastSectionObserver = new IntersectionObserver(\r\n        (entries) => {\r\n          const lastSectionEntry = entries[0];\r\n          const rect = lastSectionEntry.boundingClientRect;\r\n          const anchorBarHeight = this.getAnchorBarHeight();\r\n\r\n          if (!lastSectionEntry.isIntersecting && rect.bottom <= anchorBarHeight) {\r\n            // Past the bottom of all sections\r\n            this.isAnchorBarSticky = false;\r\n          } else if (lastSectionEntry.isIntersecting && this.isScrollingUp) {\r\n            // When scrolling back up into sections, let the anchorBarStickyObserver handle it\r\n            const anchorBarRect = this.el.getBoundingClientRect();\r\n            if (anchorBarRect.top <= 0) {\r\n              this.isAnchorBarSticky = true;\r\n              this.updateStickyOffset(true);\r\n            }\r\n          }\r\n        },\r\n        {\r\n          threshold: [0],\r\n          rootMargin: '0px 0px 0px 0px',\r\n        }\r\n      );\r\n      this.lastSectionObserver.observe(lastSection);\r\n    }\r\n  }\r\n\r\n  // Click Handlers\r\n  private setupClickHandlers() {\r\n    this.anchorItems.forEach((item) => {\r\n      item.addEventListener('click', this.handleAnchorClick);\r\n    });\r\n  }\r\n\r\n  // Move click handler to class method for proper cleanup\r\n  private handleAnchorClick = (e: Event) => {\r\n    e.preventDefault();\r\n    const item = e.currentTarget as HTMLElement;\r\n    const href = item.getAttribute('href');\r\n    this.scrollToSection(href);\r\n  };\r\n\r\n  // Helper Methods\r\n  private getHeaderHeight(): number {\r\n    if (!this.header) return 0;\r\n    return this.header.getBoundingClientRect().height;\r\n  }\r\n\r\n  private getAnchorBarHeight(): number {\r\n    return this.anchorBarContainer?.getBoundingClientRect().height ?? 0;\r\n  }\r\n\r\n  private updateStickyOffset(zero: boolean = false) {\r\n    this.el.style.setProperty('--header-offset-height', `${zero ? this.getHeaderHeight() : 0}px`);\r\n  }\r\n\r\n  private scrollToSection(href: string) {\r\n    const section = this.sectionsMap.get(href);\r\n    if (!section) return;\r\n\r\n    const scrollDirection = this.getScrollDirection(section as HTMLElement);\r\n\r\n    const headerHeight = scrollDirection === 'up' ? this.getHeaderHeight() : 0;\r\n    const anchorBarHeight = this.getAnchorBarHeight();\r\n    const safeZoneOffset = this.scrollOffset;\r\n    const totalOffset =\r\n      headerHeight +\r\n      anchorBarHeight +\r\n      (this.isAnchorBarSticky ? 0 : anchorBarHeight) +\r\n      safeZoneOffset;\r\n\r\n    // Set a CSS custom property for scroll-margin-top\r\n    (section as HTMLElement).style.scrollMarginTop = `${totalOffset}px`;\r\n\r\n    section.scrollIntoView({\r\n      behavior: 'smooth',\r\n      block: 'start',\r\n    });\r\n\r\n    // remove scroll-margin-top\r\n    (section as HTMLElement).style.removeProperty('scroll-margin-top');\r\n\r\n    // Update URL without scroll\r\n    history.pushState(null, '', href);\r\n  }\r\n\r\n  private setScrollDirection = (): void => {\r\n    const currentScrollPosition = window.scrollY;\r\n    const wasScrollingUp = this.isScrollingUp;\r\n    this.isScrollingUp = currentScrollPosition < this.lastScrollPosition;\r\n    this.lastScrollPosition = currentScrollPosition;\r\n\r\n    // Check if scroll direction changed and update offset if sticky\r\n    if (wasScrollingUp !== this.isScrollingUp && this.isAnchorBarSticky) {\r\n      this.updateStickyOffset(this.isScrollingUp);\r\n    }\r\n  };\r\n\r\n  private handleScroll = (): void => {\r\n    this.lastKnownScrollPosition = window.scrollY;\r\n\r\n    requestAnimationFrame(() => {\r\n      setTimeout(() => {\r\n        if (this.lastKnownScrollPosition === window.scrollY) {\r\n          this.updateActiveSection();\r\n        }\r\n      }, 150);\r\n    });\r\n  };\r\n\r\n  private updateActiveSection = (): void => {\r\n    // Skip updating active section if not sticky\r\n    if (!this.isAnchorBarSticky) {\r\n      this.currentIndex = -1;\r\n      this.toggleActiveAnchor(-1);\r\n      return;\r\n    }\r\n\r\n    const activeSection = this.getActiveSection();\r\n    this.currentIndex = activeSection;\r\n    this.toggleActiveAnchor(activeSection);\r\n  };\r\n\r\n  private getActiveSection = (): number => {\r\n    const headerOffset = this.isHeaderShown\r\n      ? this.getHeaderHeight() + this.getAnchorBarHeight()\r\n      : this.getAnchorBarHeight();\r\n    const currentPosition = window.scrollY + headerOffset;\r\n    let activeSection = null;\r\n\r\n    for (let i = this.sections.length - 1; i >= 0 && activeSection === null; i--) {\r\n      if (currentPosition >= this.getElementPosition(i)) {\r\n        activeSection = i;\r\n      }\r\n    }\r\n    return activeSection;\r\n  };\r\n\r\n  private getElementPosition = (index: number): number => {\r\n    const section = this.sections[index];\r\n    const headerOffset = this.isScrollingUp && this.isHeaderShown ? this.getHeaderHeight() : 0;\r\n    const anchorBarOffset = this.getAnchorBarHeight();\r\n    // Adjust the position calculation to account for header and anchor bar visibility\r\n    return section.getBoundingClientRect().top + window.scrollY - headerOffset - anchorBarOffset;\r\n  };\r\n\r\n  private toggleActiveAnchor = (index: number): void => {\r\n    const anchorElements = this.anchorItems;\r\n    for (let i = 0; i < anchorElements.length; i += 1) {\r\n      // Always remove attributes if not sticky or if not the active index\r\n      if (!this.isAnchorBarSticky || i !== index) {\r\n        anchorElements[i].removeAttribute('selected');\r\n        anchorElements[i].removeAttribute('aria-current');\r\n        continue;\r\n      }\r\n\r\n      // Only set attributes if sticky and is active index\r\n      anchorElements[i].setAttribute('selected', '');\r\n      anchorElements[i].setAttribute('aria-current', 'location');\r\n\r\n      if (i !== 0 && this.hasOverflow && this.isAnchorBarSticky) {\r\n        anchorElements[i].scrollIntoView({\r\n          behavior: 'smooth',\r\n          inline: 'center',\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  private getScrollDirection(targetSection: HTMLElement): 'up' | 'down' {\r\n    const currentSection = this.currentIndex !== -1 ? this.sections[this.currentIndex] : null;\r\n    if (!currentSection) {\r\n      return targetSection.getBoundingClientRect().top > window.innerHeight / 2 ? 'down' : 'up';\r\n    }\r\n    return targetSection.getBoundingClientRect().top < currentSection.getBoundingClientRect().top\r\n      ? 'up'\r\n      : 'down';\r\n  }\r\n\r\n  private checkForOverflow = () => {\r\n    if (!this.anchorBarContainer) return;\r\n\r\n    const { width: containerWidth } = this.anchorBarContainer.getBoundingClientRect();\r\n    const { INLINE_PADDING, OVERFLOW_BUTTON_WIDTH, OVERFLOW_BUTTON_GAP } = this.LAYOUT;\r\n\r\n    const availableWidth =\r\n      containerWidth - INLINE_PADDING * 2 - OVERFLOW_BUTTON_WIDTH * 2 - OVERFLOW_BUTTON_GAP * 2;\r\n\r\n    const itemsWidth = this.anchorItems.reduce(\r\n      (acc, item) => acc + item.getBoundingClientRect().width + this.LAYOUT.ITEM_GAP,\r\n      -this.LAYOUT.ITEM_GAP // Subtract one gap since we don't need it after the last item\r\n    );\r\n\r\n    this.hasOverflow = itemsWidth > availableWidth;\r\n  };\r\n\r\n  private handleOverflowButtonClick(direction: 'left' | 'right') {\r\n    const nextIndex =\r\n      direction === 'left'\r\n        ? Math.max(0, this.currentIndex - 1)\r\n        : Math.min(this.anchorItems.length - 1, this.currentIndex + 1);\r\n\r\n    if (nextIndex !== this.currentIndex) {\r\n      this.scrollToSection(this.anchorItems[nextIndex].getAttribute('href'));\r\n    }\r\n  }\r\n\r\n  private updateButtonStates() {\r\n    this.isAtStart = this.currentIndex <= 0;\r\n    this.isAtEnd = this.currentIndex >= this.anchorItems.length - 1;\r\n  }\r\n\r\n  // Render\r\n  render() {\r\n    const overflowButtonLeft = (\r\n      <dc-ui-button\r\n        icon=\"dc_backward_left\"\r\n        variant=\"link\"\r\n        size=\"small\"\r\n        hide-label=\"true\"\r\n        disabled={this.isAtStart}\r\n        onClick={() => this.handleOverflowButtonClick('left')}>\r\n        Go to previous section\r\n      </dc-ui-button>\r\n    );\r\n\r\n    const overflowButtonRight = (\r\n      <dc-ui-button\r\n        icon=\"dc_forward_right\"\r\n        variant=\"link\"\r\n        size=\"small\"\r\n        hide-label=\"true\"\r\n        disabled={this.isAtEnd}\r\n        onClick={() => this.handleOverflowButtonClick('right')}>\r\n        Go to next section\r\n      </dc-ui-button>\r\n    );\r\n\r\n    return (\r\n      <div\r\n        class={{\r\n          'dc-ui-anchor-bar': true,\r\n          'dc-ui-anchor-bar--is-sticky': this.isAnchorBarSticky,\r\n        }}>\r\n        <div\r\n          class={{\r\n            'dc-ui-anchor-bar__inner': true,\r\n            'dc-ui-anchor-bar__inner--has-overflow': this.hasOverflow,\r\n          }}\r\n          ref={(el) => (this.anchorBarContainer = el)}>\r\n          {this.hasOverflow && overflowButtonLeft}\r\n          <nav class=\"dc-ui-anchor-bar__inner-wrapper\">\r\n            <slot></slot>\r\n          </nav>\r\n          {this.hasOverflow && overflowButtonRight}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}