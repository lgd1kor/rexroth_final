{"version":3,"file":"static/js/541.316b0e45.chunk.js","mappings":"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","sources":["../node_modules/@boschrexroth/nextgen-web-ui-toolkit/dist/esm/src/utils/variables/color.ts","../node_modules/@boschrexroth/nextgen-web-ui-toolkit/dist/esm/src/components/dc-ui-tooltip/tooltip-utils.ts","../node_modules/@boschrexroth/nextgen-web-ui-toolkit/dist/esm/src/components/dc-ui-tooltip/tooltip-styles.ts","../node_modules/@boschrexroth/nextgen-web-ui-toolkit/dist/esm/src/components/dc-ui-tooltip/dc-ui-tooltip.tsx"],"sourcesContent":["export const color = {\r\n  focusColor: '#009cc2',\r\n\r\n  redBrand01: '#ed0007',\r\n  redBrand02: '#d50005',\r\n  redBrand03: '#a80003',\r\n\r\n  turquoise01: '#00c8f7',\r\n  turquoise02: '#00b9e5',\r\n  turquoise03: '#009cc2',\r\n  turquoise04: '#00738f',\r\n  turquoise05: '#004d61',\r\n  turquoise06: '#002936',\r\n\r\n  grey01: '#edf1f4',\r\n  grey02: '#cad6dd',\r\n  grey03: '#a3bac8',\r\n  grey04: '#99aebb',\r\n  grey05: '#7995a6',\r\n  grey06: '#506e81',\r\n  grey07: '#476273',\r\n  grey08: '#354956',\r\n  grey09: '#2d3e48',\r\n  grey10: '#1c272e',\r\n\r\n  green01: '#d9e8d0',\r\n  green02: '#528236',\r\n  green03: '#1a2a11',\r\n\r\n  yellow01: '#f9f3bc',\r\n  yellow02: '#ebd417',\r\n  yellow03: '#2a2604',\r\n\r\n  red01: '#f7bfc8',\r\n  red02: '#da1e28',\r\n  red03: '#54000e',\r\n\r\n  orange01: '#FBE8DA',\r\n  orange02: '#DC641E',\r\n\r\n  darkBlue01: '#d1dce3',\r\n  darkBlue02: '#002b49',\r\n  darkBlue03: '#00243e',\r\n\r\n  white: '#ffffff',\r\n  black: '#000000',\r\n};\r\n\r\nexport type TColor = keyof typeof color;\r\nexport type TBGColor = 'grey01' | 'turquoise01' | 'darkBlue02';\r\n","import { DcUiTooltip } from './dc-ui-tooltip';\r\nimport { injectCSS } from '../../utils';\r\nimport { createStyles } from './tooltip-styles';\r\n\r\nexport const ARROW_SIZE = 14; // width/height of the arrow (px)\r\nexport const TOOLTIP_MARGIN = 16; // distance from the tooltip to the trigger element (px)\r\nexport const VIEWPORT_MARGIN = 4; // how close the tooltip can come to the edge of the viewport (px)\r\nexport const TRANSITION_TIME = 300; // tooltip fade-in transition time (ms)\r\n\r\nexport const TOOLTIP_PLACEMENTS = ['top', 'bottom', 'left', 'right'] as const;\r\nexport type TTooltipPlacement = typeof TOOLTIP_PLACEMENTS[number];\r\n\r\nexport const TOOLTIP_TRIGGERS = ['click', 'hover'] as const;\r\nexport type TTooltipTrigger = typeof TOOLTIP_TRIGGERS[number];\r\n\r\nexport const registeredTooltips: DcUiTooltip[] = [];\r\n\r\n/**\r\n *\r\n * Toggles the tooltip's open state.\r\n *\r\n * @param tooltip\r\n */\r\nexport const toggleTooltip = (tooltip: DcUiTooltip, event: Event): void => {\r\n  if (tooltip.opening || tooltip.closing) {\r\n    return;\r\n  }\r\n  if (!tooltip.open) {\r\n    openTooltip(tooltip);\r\n  } else {\r\n    closeTooltip(tooltip, event);\r\n  }\r\n};\r\n\r\n/**\r\n *\r\n * Opens the tooltip.\r\n *\r\n * @param tooltip\r\n */\r\nexport const openTooltip = (tooltip: DcUiTooltip): void => {\r\n  clearTimeout(tooltip.timeoutID);\r\n  updateTooltipPosition(tooltip);\r\n  addDocumentListeners(tooltip);\r\n\r\n  for (const other of registeredTooltips) {\r\n    if (other !== tooltip && !tooltip.isNestedTrigger) {\r\n      closeTooltipInstantly(other);\r\n    }\r\n  }\r\n\r\n  tooltip.triggerEl.setAttribute('aria-expanded', 'true');\r\n  tooltip.containerEl.removeAttribute('hidden');\r\n  tooltip.containerEl.removeAttribute('aria-hidden');\r\n  setTimeout(() => {\r\n    tooltip.opening = true;\r\n    tooltip.closing = false;\r\n  }, 0);\r\n\r\n  // I'd use an event listener on transitionend (with {once: true})\r\n  // but that seems to bug out in Firefox when rapidly opening/closing\r\n  tooltip.timeoutID = setTimeout(() => {\r\n    tooltip.opening = false;\r\n    tooltip.open = true;\r\n  }, TRANSITION_TIME);\r\n};\r\n\r\n/**\r\n *\r\n * Closes the tooltip.\r\n *\r\n * @param tooltip\r\n */\r\nexport const closeTooltip = (tooltip: DcUiTooltip, event?: Event): void => {\r\n  const eventSrc = event?.target as HTMLElement;\r\n  const eventTargetisTrigger = !!event && tooltip.triggerEl.contains(eventSrc);\r\n\r\n  // only close tooltip if no event was passed, or if the event target is not inside the tooltip\r\n  if (event && tooltip.el.contains(event.target as Node)) {\r\n    return;\r\n  }\r\n\r\n  // if event target is tooltip trigger only close this tooltip\r\n  if (eventTargetisTrigger) {\r\n    clearTimeout(tooltip.timeoutID);\r\n    tooltip.closing = true;\r\n    tooltip.opening = false;\r\n    updateTooltipPosition(tooltip);\r\n\r\n    // I'd use an event listener on transitionend (with {once: true})\r\n    // but that seems to bug out in Firefox when rapidly opening/closing\r\n    tooltip.timeoutID = setTimeout(() => {\r\n      tooltip.closing = false;\r\n      tooltip.open = false;\r\n      tooltip.containerEl.setAttribute('hidden', 'hidden');\r\n      tooltip.containerEl.setAttribute('aria-hidden', 'true');\r\n      tooltip.triggerEl.setAttribute('aria-expanded', 'false');\r\n    }, TRANSITION_TIME);\r\n    removeDocumentListeners(tooltip);\r\n    return;\r\n  }\r\n\r\n  for (const any of registeredTooltips) {\r\n    clearTimeout(any.timeoutID);\r\n    any.closing = true;\r\n    any.opening = false;\r\n    updateTooltipPosition(any);\r\n\r\n    if (any.isNestedTrigger) {\r\n      any.closing = false;\r\n      any.open = false;\r\n      any.containerEl.setAttribute('hidden', 'hidden');\r\n      any.containerEl.setAttribute('aria-hidden', 'true');\r\n      any.triggerEl.setAttribute('aria-expanded', 'false');\r\n    } else {\r\n      // I'd use an event listener on transitionend (with {once: true})\r\n      // but that seems to bug out in Firefox when rapidly opening/closing\r\n      any.timeoutID = setTimeout(() => {\r\n        any.closing = false;\r\n        any.open = false;\r\n        any.containerEl.setAttribute('hidden', 'hidden');\r\n        any.containerEl.setAttribute('aria-hidden', 'true');\r\n        any.triggerEl.setAttribute('aria-expanded', 'false');\r\n      }, TRANSITION_TIME);\r\n    }\r\n  }\r\n\r\n  registeredTooltips.map((tooltip) => {\r\n    removeDocumentListeners(tooltip);\r\n  });\r\n};\r\n\r\n/**\r\n *\r\n * Closes the tooltip instantly.\r\n *\r\n * @param tooltip\r\n */\r\nexport const closeTooltipInstantly = (tooltip: DcUiTooltip): void => {\r\n  clearTimeout(tooltip.timeoutID);\r\n  removeDocumentListeners(tooltip);\r\n  updateTooltipPosition(tooltip);\r\n  tooltip.closing = false;\r\n  tooltip.open = false;\r\n  tooltip.containerEl.setAttribute('hidden', 'hidden');\r\n  tooltip.containerEl.setAttribute('aria-hidden', 'true');\r\n  tooltip.triggerEl.setAttribute('aria-expanded', 'false');\r\n};\r\n\r\n/**\r\n * Closes all tooltips.\r\n *\r\n * Called on document click.\r\n */\r\nexport const onDocumentClick = (e: MouseEvent): void => {\r\n  for (const tooltip of registeredTooltips) {\r\n    closeTooltip(tooltip, e);\r\n  }\r\n};\r\n\r\n/**\r\n * Closes all tooltips if the Escape key is pressed.\r\n *\r\n * Called on document keydown.\r\n */\r\nexport const onDocumentKeydown = (e: KeyboardEvent): void => {\r\n  if (e.key === 'Escape') {\r\n    for (const tooltip of registeredTooltips) {\r\n      closeTooltip(tooltip, e);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Adds event listeners to toggle the tooltip.\r\n *\r\n * @param tooltip\r\n */\r\nexport const addTriggerListeners = (tooltip: DcUiTooltip): void => {\r\n  tooltip.el.addEventListener('click', tooltip.onTooltipClick);\r\n\r\n  if (tooltip.trigger === 'hover') {\r\n    tooltip.triggerEl.addEventListener('focus', tooltip.onTriggerMouseOver);\r\n    tooltip.triggerEl.addEventListener('mouseover', tooltip.onTriggerMouseOver);\r\n    tooltip.triggerEl.addEventListener('blur', tooltip.onTriggerMouseOut);\r\n    tooltip.triggerEl.addEventListener('mouseout', tooltip.onTriggerMouseOut);\r\n    tooltip.triggerEl.addEventListener('touchstart', tooltip.onTriggerTouchStart);\r\n  } else {\r\n    tooltip.triggerEl.addEventListener('click', tooltip.onTriggerClick);\r\n    tooltip.triggerEl.addEventListener('keydown', tooltip.onTriggerKeyDown);\r\n  }\r\n};\r\n\r\n/**\r\n * Removes event listeners to toggle the tooltip.\r\n *\r\n * @param tooltip\r\n */\r\nexport const removeTriggerListeners = (tooltip: DcUiTooltip): void => {\r\n  tooltip.el.removeEventListener('click', tooltip.onTooltipClick);\r\n\r\n  if (tooltip.trigger === 'hover') {\r\n    tooltip.triggerEl.removeEventListener('focus', tooltip.onTriggerMouseOver);\r\n    tooltip.triggerEl.removeEventListener('mouseover', tooltip.onTriggerMouseOver);\r\n    tooltip.triggerEl.removeEventListener('blur', tooltip.onTriggerMouseOut);\r\n    tooltip.triggerEl.removeEventListener('mouseout', tooltip.onTriggerMouseOut);\r\n    tooltip.triggerEl.removeEventListener('touchstart', tooltip.onTriggerTouchStart);\r\n  } else {\r\n    tooltip.triggerEl.removeEventListener('click', tooltip.onTriggerClick);\r\n    tooltip.triggerEl.removeEventListener('keydown', tooltip.onTriggerKeyDown);\r\n  }\r\n};\r\n\r\n/**\r\n * Adds event listeners to the document if they don't already exist.\r\n *\r\n * Also adds the tooltip to the list of registered tooltips.\r\n *\r\n * @param tooltip\r\n */\r\nexport const addDocumentListeners = (tooltip: DcUiTooltip): void => {\r\n  if (registeredTooltips.length === 0) {\r\n    document.addEventListener('scroll', onScrollOrResize);\r\n    window.addEventListener('resize', onScrollOrResize);\r\n    document.addEventListener('click', onDocumentClick);\r\n    document.addEventListener('keydown', onDocumentKeydown);\r\n  }\r\n  if (!registeredTooltips.includes(tooltip)) {\r\n    registeredTooltips.push(tooltip);\r\n  }\r\n};\r\n\r\n/**\r\n * Removes event listeners from the document if they're no longer needed.\r\n *\r\n * Also removes the tooltip from the list of registered tooltips.\r\n *\r\n * @param tooltip\r\n */\r\nexport const removeDocumentListeners = (tooltip: DcUiTooltip): void => {\r\n  const index = registeredTooltips.indexOf(tooltip);\r\n  if (index > -1) {\r\n    registeredTooltips.splice(index, 1);\r\n  }\r\n  if (registeredTooltips.length === 0) {\r\n    document.removeEventListener('scroll', onScrollOrResize);\r\n    window.removeEventListener('resize', onScrollOrResize);\r\n    document.removeEventListener('click', onDocumentClick);\r\n    document.removeEventListener('keydown', onDocumentKeydown);\r\n  }\r\n};\r\n\r\n/**\r\n * Updates the positions of all registered tooltips.\r\n *\r\n * Called on document scroll or window resize.\r\n */\r\nexport const onScrollOrResize = (): void => {\r\n  for (const tooltip of registeredTooltips) {\r\n    updateTooltipPosition(tooltip);\r\n  }\r\n};\r\n\r\n/**\r\n * Updates the position of a tooltip.\r\n *\r\n * @param tooltip\r\n */\r\nexport const updateTooltipPosition = (tooltip: DcUiTooltip): void => {\r\n  let arrowOffset = 0;\r\n  let actualPlacement: TTooltipPlacement = tooltip.placement;\r\n  const originalPlacement: TTooltipPlacement = tooltip.placement;\r\n  let tooltipWidth: number = null;\r\n  tooltip.el.style.width = null;\r\n\r\n  let tooltipRect = tooltip.el.getBoundingClientRect();\r\n  const triggerRect = tooltip.triggerEl.getBoundingClientRect();\r\n\r\n  // calculate \"desired\" positions\r\n  let [targetXPos, targetYPos] = targetPosition(tooltipRect, triggerRect, actualPlacement);\r\n\r\n  // if the tooltip is out of bounds, adjust the placement\r\n  [targetXPos, targetYPos, actualPlacement] = checkAndAdjustPlacement(\r\n    targetXPos,\r\n    targetYPos,\r\n    actualPlacement,\r\n    originalPlacement,\r\n    tooltipRect,\r\n    triggerRect\r\n  );\r\n\r\n  // for top and bottom placements: if it's still out of bounds, adjust the position, arrow offset and width\r\n  if (['top', 'bottom'].includes(actualPlacement)) {\r\n    [targetXPos, targetYPos, arrowOffset, tooltipWidth] = handleOutOfBoundsHorizontally(\r\n      targetXPos,\r\n      targetYPos,\r\n      tooltipRect,\r\n      triggerRect\r\n    );\r\n\r\n    // apply the calculated width\r\n    tooltip.el.style.width = tooltipWidth === null ? null : `${tooltipWidth}px`;\r\n\r\n    // the width change may have changed the height too, so recalculate the target Y position\r\n    tooltipRect = tooltip.el.getBoundingClientRect();\r\n    targetYPos = targetPosition(tooltipRect, triggerRect, actualPlacement)[1];\r\n  }\r\n\r\n  // for left and right placements: if it's still out of bounds, adjust the position and arrow offset\r\n  if (['left', 'right'].includes(actualPlacement)) {\r\n    [targetYPos, arrowOffset] = handleOutOfBoundsVertically(targetYPos, tooltipRect, triggerRect);\r\n  }\r\n\r\n  // re-inject the CSS to update the placement and arrow position\r\n  injectCSS(\r\n    tooltip.el,\r\n    createStyles,\r\n    actualPlacement,\r\n    arrowOffset,\r\n    tooltip.maxWidth,\r\n    tooltip.isNestedTrigger\r\n  );\r\n\r\n  // apply the calculated position\r\n  tooltip.el.style.transform = `translate(${targetXPos}px, ${targetYPos}px)`;\r\n};\r\n\r\n/**\r\n * Changes the placement of a tooltip if it's outside the viewport bounds.\r\n *\r\n * If there is no placement that works, it falls back to either \"top\" or \"bottom\".\r\n *\r\n * @param targetXPos\r\n * @param targetYPos\r\n * @param placement\r\n * @param originalPlacement\r\n * @param tooltipRect\r\n * @param triggerRect\r\n */\r\nconst checkAndAdjustPlacement = (\r\n  targetXPos: number,\r\n  targetYPos: number,\r\n  placement: TTooltipPlacement,\r\n  originalPlacement: TTooltipPlacement,\r\n  tooltipRect: DOMRect,\r\n  triggerRect: DOMRect\r\n): [number, number, TTooltipPlacement] => {\r\n  // if the tooltip is out of bounds, try changing the placement (2 tries)\r\n  for (let i = 0; i <= 1; i++) {\r\n    // left/right only needs to change to top/bottom if it's out of bounds horizontally,\r\n    // top/bottom  only needs to change to left/right if it's out of bounds vertically\r\n    // other kinds of overflow are handled later\r\n    if (\r\n      (['left', 'right'].includes(placement) && outOfBoundsHorizontally(tooltipRect, targetXPos)) ||\r\n      (['top', 'bottom'].includes(placement) &&\r\n        outOfBoundsVerticallyIncludingScrolling(tooltipRect, targetYPos))\r\n    ) {\r\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n      // @ts-ignore\r\n      placement = {\r\n        left: 'top',\r\n        top: 'right',\r\n        right: 'bottom',\r\n        bottom: 'left',\r\n      }[placement];\r\n      [targetXPos, targetYPos] = targetPosition(tooltipRect, triggerRect, placement);\r\n    }\r\n  }\r\n\r\n  // if it's *still* out of bounds, at least make sure it's on the top or bottom\r\n  if (\r\n    outOfBoundsHorizontally(tooltipRect, targetXPos) ||\r\n    outOfBoundsVerticallyIncludingScrolling(tooltipRect, targetYPos)\r\n  ) {\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n    // @ts-ignore\r\n    placement = {\r\n      left: 'top',\r\n      top: 'top',\r\n      right: 'bottom',\r\n      bottom: 'bottom',\r\n    }[originalPlacement];\r\n    [targetXPos, targetYPos] = targetPosition(tooltipRect, triggerRect, placement);\r\n  }\r\n\r\n  // if it's *still* out of bounds vertically, then change top to bottom and vice versa\r\n  if (outOfBoundsVerticallyIncludingScrolling(tooltipRect, targetYPos)) {\r\n    placement = placement === 'top' ? 'bottom' : 'top';\r\n    [targetXPos, targetYPos] = targetPosition(tooltipRect, triggerRect, placement);\r\n  }\r\n\r\n  return [targetXPos, targetYPos, placement];\r\n};\r\n\r\n/**\r\n * Changes the position, width and arrow position of a tooltip if it's outside the viewport horizontally.\r\n *\r\n * This uses different logic than handleOutOfBoundsVertically,\r\n * because horizontal and vertical overflow are different use cases.\r\n *\r\n * @param targetXPos\r\n * @param targetYPos\r\n * @param tooltipRect\r\n * @param triggerRect\r\n */\r\nconst handleOutOfBoundsHorizontally = (\r\n  targetXPos: number,\r\n  targetYPos: number,\r\n  tooltipRect: DOMRect,\r\n  triggerRect: DOMRect\r\n): number[] => {\r\n  let tooltipWidth = null;\r\n\r\n  // if it's out of bounds on the left,\r\n  // move it right, then check if it's out of bounds on the right and cut off the excess width\r\n  if (targetXPos < VIEWPORT_MARGIN) {\r\n    targetXPos = VIEWPORT_MARGIN;\r\n    if (targetXPos + tooltipRect.width >= document.body.clientWidth - VIEWPORT_MARGIN) {\r\n      const diff = tooltipRect.width - (document.body.clientWidth - 2 * VIEWPORT_MARGIN);\r\n      tooltipWidth = tooltipRect.width - diff;\r\n    }\r\n  }\r\n\r\n  // if it's out of bounds on the right,\r\n  // move it left, then check if it's out of bounds on the left and cut off the excess width\r\n  if (targetXPos + tooltipRect.width >= document.body.clientWidth - VIEWPORT_MARGIN) {\r\n    targetXPos = document.body.clientWidth - tooltipRect.width - VIEWPORT_MARGIN;\r\n    if (targetXPos < VIEWPORT_MARGIN) {\r\n      const diff = tooltipRect.width - (document.body.clientWidth - 2 * VIEWPORT_MARGIN);\r\n      targetXPos = targetXPos + diff;\r\n      tooltipWidth = tooltipRect.width - diff;\r\n    }\r\n  }\r\n\r\n  // point the arrow to the center of the trigger\r\n  const width = tooltipWidth !== null ? tooltipWidth : tooltipRect.width;\r\n  const triggerCenter = triggerRect.x + triggerRect.width / 2;\r\n  const tooltipCenter = targetXPos + width / 2;\r\n  const targetOffset = triggerCenter - tooltipCenter;\r\n\r\n  // constrain the arrow to be within the tooltip\r\n  const limit = (width - ARROW_SIZE) / 2;\r\n  const arrowOffset = clamp(targetOffset, -limit, limit);\r\n\r\n  return [targetXPos, targetYPos, arrowOffset, tooltipWidth];\r\n};\r\n\r\n/**\r\n * Changes the position and arrow position of a tooltip if it's outside the viewport vertically.\r\n *\r\n * This uses different logic than handleOutOfBoundsHorizontally,\r\n * because horizontal and vertical overflow are different use cases.\r\n *\r\n * @param targetYPos\r\n * @param tooltipRect\r\n * @param triggerRect\r\n */\r\nconst handleOutOfBoundsVertically = (\r\n  targetYPos: number,\r\n  tooltipRect: DOMRect,\r\n  triggerRect: DOMRect\r\n): number[] => {\r\n  let arrowOffset = 0;\r\n\r\n  // case 1: trigger is off-screen (so far up that the tooltip has to move off-screen with it)\r\n  if (triggerRect.bottom < VIEWPORT_MARGIN) {\r\n    // make the tooltip move with the bottom of the trigger\r\n    targetYPos = triggerRect.bottom;\r\n    // put the arrow at the very top\r\n    arrowOffset = (ARROW_SIZE - tooltipRect.height) / 2;\r\n  }\r\n\r\n  // case 2: trigger is so far up that the tooltip can't be where it wants to (but can still be visible)\r\n  else if (targetYPos < VIEWPORT_MARGIN) {\r\n    // make the tooltip stick to the top of the viewport\r\n    targetYPos = VIEWPORT_MARGIN;\r\n    // point the arrow to the center of the trigger (but no further down than the center of the tooltip)\r\n    const tooltipCenter = targetYPos + tooltipRect.height / 2;\r\n    const triggerCenter = triggerRect.top + triggerRect.height / 2;\r\n    const targetArrowPos = Math.min(triggerCenter, tooltipCenter);\r\n    arrowOffset = targetArrowPos - tooltipCenter;\r\n  }\r\n\r\n  // case 3: trigger is off-screen (so far down that the tooltip has to move off-screen with it)\r\n  else if (triggerRect.top > window.innerHeight - VIEWPORT_MARGIN) {\r\n    // make the tooltip move with the top of the trigger\r\n    targetYPos = triggerRect.top - tooltipRect.height;\r\n    // put the arrow at the very bottom\r\n    arrowOffset = (tooltipRect.height - ARROW_SIZE) / 2;\r\n  }\r\n\r\n  // case 4: trigger is so far down that the tooltip can't be where it wants to (but can still be visible)\r\n  else if (targetYPos + tooltipRect.height > window.innerHeight - VIEWPORT_MARGIN) {\r\n    // make the tooltip stick to the bottom of the viewport\r\n    targetYPos = window.innerHeight - VIEWPORT_MARGIN - tooltipRect.height;\r\n    // point the arrow to the center of the trigger (but no further up than the center of the tooltip)\r\n    const tooltipCenter = targetYPos + tooltipRect.height / 2;\r\n    const triggerCenter = triggerRect.top + triggerRect.height / 2;\r\n    const targetArrowPos = Math.max(triggerCenter, tooltipCenter);\r\n    arrowOffset = targetArrowPos - tooltipCenter;\r\n  }\r\n\r\n  // constrain the arrow to be within the tooltip\r\n  const limit = (tooltipRect.height - ARROW_SIZE) / 2;\r\n  arrowOffset = clamp(arrowOffset, -limit, limit);\r\n\r\n  return [targetYPos, arrowOffset];\r\n};\r\n\r\n/**\r\n * Checks if a tooltip is outside the viewport horizontally (left or right).\r\n *\r\n * @param tooltipRect\r\n * @param targetXPos\r\n */\r\nconst outOfBoundsHorizontally = (tooltipRect: DOMRect, targetXPos: number): boolean => {\r\n  return (\r\n    targetXPos < VIEWPORT_MARGIN ||\r\n    targetXPos + tooltipRect.width > document.body.clientWidth - VIEWPORT_MARGIN\r\n  );\r\n};\r\n\r\n/**\r\n * Checks if a tooltip is outside the viewport vertically (top or bottom), taking scrolling into account.\r\n *\r\n * If the tooltip is outside the viewport, but there's room to scroll it back into view,\r\n * it doesn't count as \"outside the viewport\".\r\n *\r\n * @param tooltipRect\r\n * @param targetYPos\r\n */\r\nconst outOfBoundsVerticallyIncludingScrolling = (\r\n  tooltipRect: DOMRect,\r\n  targetYPos: number\r\n): boolean => {\r\n  const scrollDistFromTop = window.scrollY;\r\n  const scrollDistFromBottom = document.body.scrollHeight - window.innerHeight - window.scrollY;\r\n  return (\r\n    targetYPos < VIEWPORT_MARGIN - scrollDistFromTop ||\r\n    targetYPos + tooltipRect.height > window.innerHeight + scrollDistFromBottom - VIEWPORT_MARGIN\r\n  );\r\n};\r\n\r\n/**\r\n *\r\n * Calculates the tooltip position given the trigger element and the tooltip placement.\r\n *\r\n * Note that this is just the \"desired\" position.\r\n * It can (and will) be changed by the calling function if it makes the tooltip go out of bounds.\r\n *\r\n * @param tooltipRect\r\n * @param triggerRect\r\n * @param placement\r\n */\r\nconst targetPosition = (\r\n  tooltipRect: DOMRect,\r\n  triggerRect: DOMRect,\r\n  placement: TTooltipPlacement\r\n): number[] => {\r\n  const targetXPos = {\r\n    top: triggerRect.left + triggerRect.width / 2 - tooltipRect.width / 2,\r\n    right: triggerRect.right + TOOLTIP_MARGIN,\r\n    bottom: triggerRect.left + triggerRect.width / 2 - tooltipRect.width / 2,\r\n    left: triggerRect.left - tooltipRect.width - TOOLTIP_MARGIN,\r\n  }[placement];\r\n\r\n  const targetYPos = {\r\n    top: triggerRect.top - tooltipRect.height - TOOLTIP_MARGIN,\r\n    right: triggerRect.top + triggerRect.height / 2 - tooltipRect.height / 2,\r\n    bottom: triggerRect.bottom + TOOLTIP_MARGIN,\r\n    left: triggerRect.top + triggerRect.height / 2 - tooltipRect.height / 2,\r\n  }[placement];\r\n\r\n  return [targetXPos, targetYPos];\r\n};\r\n\r\nfunction clamp(val, min, max) {\r\n  return val > max ? max : val < min ? min : val;\r\n}\r\n","import { color as colorUtils, getCss } from '../../utils';\r\nimport { TTooltipPlacement, ARROW_SIZE, TRANSITION_TIME } from './tooltip-utils';\r\n\r\nconst arrowBorder = `${ARROW_SIZE / 2}px solid ${colorUtils.grey03}`;\r\nconst arrowBackground = `${ARROW_SIZE / 2}px solid ${colorUtils.white}`;\r\n\r\nfunction arrowStyles(placement: TTooltipPlacement, arrowOffset) {\r\n  return {\r\n    top: {\r\n      bottom: '0',\r\n      left: '50%',\r\n      transform: `translateX(-50%) translateX(${arrowOffset}px)`,\r\n    },\r\n    right: {\r\n      left: '0',\r\n      top: '50%',\r\n      transform: `translateY(-50%) translateY(${arrowOffset}px)`,\r\n    },\r\n    bottom: {\r\n      top: '0',\r\n      left: '50%',\r\n      transform: `translateX(-50%) translateX(${arrowOffset}px)`,\r\n    },\r\n    left: {\r\n      right: '0',\r\n      top: '50%',\r\n      transform: `translateY(-50%) translateY(${arrowOffset}px)`,\r\n    },\r\n  }[placement];\r\n}\r\n\r\nfunction arrowBeforeStyles(placement: TTooltipPlacement) {\r\n  return {\r\n    top: {\r\n      bottom: `-${ARROW_SIZE + 1}px`,\r\n      borderTop: arrowBorder,\r\n    },\r\n    right: {\r\n      left: `-${ARROW_SIZE + 1}px`,\r\n      borderRight: arrowBorder,\r\n    },\r\n    bottom: {\r\n      top: `-${ARROW_SIZE + 1}px`,\r\n      borderBottom: arrowBorder,\r\n    },\r\n    left: {\r\n      right: `-${ARROW_SIZE + 1}px`,\r\n      borderLeft: arrowBorder,\r\n    },\r\n  }[placement];\r\n}\r\n\r\nfunction arrowAfterStyles(placement: TTooltipPlacement) {\r\n  return {\r\n    top: {\r\n      bottom: `-${ARROW_SIZE}px`,\r\n      borderTop: arrowBackground,\r\n    },\r\n    right: {\r\n      left: `-${ARROW_SIZE}px`,\r\n      borderRight: arrowBackground,\r\n    },\r\n    bottom: {\r\n      top: `-${ARROW_SIZE}px`,\r\n      borderBottom: arrowBackground,\r\n    },\r\n    left: {\r\n      right: `-${ARROW_SIZE}px`,\r\n      borderLeft: arrowBackground,\r\n    },\r\n  }[placement];\r\n}\r\n\r\nexport const createStyles = (\r\n  placement: TTooltipPlacement,\r\n  arrowOffset: number,\r\n  maxWidth: number,\r\n  nested: boolean\r\n): string => {\r\n  const styles = getCss({\r\n    '@global': {\r\n      ':host': {\r\n        display: 'block',\r\n        width: 'fit-content',\r\n        maxWidth: `${maxWidth}px`,\r\n        position: 'fixed',\r\n        top: '0',\r\n        left: '0',\r\n        zIndex: nested ? '10000' : '9999',\r\n        pointerEvents: 'none',\r\n      },\r\n\r\n      '.dc-ui-tooltip__container': {\r\n        position: 'relative',\r\n        border: `1px solid ${colorUtils.grey02}`,\r\n        backgroundColor: colorUtils.white,\r\n        // using drop-shadow instead of box-shadow adds shadow to the arrow as well\r\n        // note: for drop-shadow, the blur radius needs to be halved (6px --> 3px) to give the same result as box-shadow\r\n        filter: 'drop-shadow(0 2px 3px rgba(0, 0, 0, 0.3))',\r\n        padding: '1rem',\r\n        opacity: 0,\r\n        pointerEvents: 'none',\r\n\r\n        '&--opening, &--closing': {\r\n          transition: `opacity ${TRANSITION_TIME}ms`,\r\n        },\r\n\r\n        '&--opening, &--open': {\r\n          opacity: 1,\r\n          pointerEvents: 'initial',\r\n        },\r\n\r\n        '&--closing': {\r\n          opacity: 0,\r\n        },\r\n      },\r\n\r\n      '.dc-ui-tooltip__arrow': {\r\n        position: 'absolute',\r\n        width: `${ARROW_SIZE}px`,\r\n        height: `${ARROW_SIZE}px`,\r\n        ...arrowStyles(placement, arrowOffset),\r\n\r\n        '&::before, &::after': {\r\n          content: '\"\"',\r\n          position: 'absolute',\r\n          width: '0',\r\n          height: '0',\r\n          border: `${ARROW_SIZE / 2}px solid transparent`,\r\n        },\r\n\r\n        '&::before': {\r\n          ...arrowBeforeStyles(placement),\r\n        },\r\n\r\n        '&::after': {\r\n          ...arrowAfterStyles(placement),\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  return styles;\r\n};\r\n","import { Component, Host, h, Element, Prop, State, Method } from '@stencil/core';\r\nimport { createUuid, injectCSS } from '../../utils';\r\nimport { createStyles } from './tooltip-styles';\r\nimport {\r\n  TTooltipPlacement,\r\n  TTooltipTrigger,\r\n  removeDocumentListeners,\r\n  updateTooltipPosition,\r\n  toggleTooltip,\r\n  openTooltip,\r\n  closeTooltip,\r\n  addTriggerListeners,\r\n  removeTriggerListeners,\r\n} from './tooltip-utils';\r\n\r\n@Component({\r\n  tag: 'dc-ui-tooltip',\r\n  shadow: true,\r\n})\r\nexport class DcUiTooltip {\r\n  @Element() el: HTMLElement;\r\n  @Prop() placement: TTooltipPlacement = 'top';\r\n  @Prop() content: string = null;\r\n  @Prop() trigger: TTooltipTrigger = 'hover';\r\n  @Prop() triggerElement = '';\r\n  @Prop() maxWidth = 500;\r\n  @Prop() hoverDelay = 0;\r\n\r\n  @State() open = false;\r\n  @State() opening = false;\r\n  @State() closing = false;\r\n\r\n  triggerEl: HTMLElement;\r\n  containerEl: HTMLElement;\r\n  slotEl: Element;\r\n  contentEl: Element;\r\n  uuid: string;\r\n  timeoutID: ReturnType<typeof setTimeout>;\r\n  isNestedTooltip: boolean;\r\n  isNestedTrigger: boolean;\r\n  hasNestedTooltip: boolean;\r\n\r\n  @Method() show(): Promise<boolean> {\r\n    return new Promise((resolve) => {\r\n      openTooltip(this);\r\n      resolve(true);\r\n    });\r\n  }\r\n\r\n  @Method() hide(): Promise<boolean> {\r\n    return new Promise((resolve) => {\r\n      closeTooltip(this);\r\n      resolve(true);\r\n    });\r\n  }\r\n\r\n  connectedCallback() {\r\n    // get reference of the root element\r\n    const shadowRoot = this.el.getRootNode() as ShadowRoot;\r\n\r\n    // search for trigger element. Either in light DOM or in shadow DOM\r\n    this.triggerEl = shadowRoot.getElementById(this.triggerElement);\r\n  }\r\n\r\n  componentWillLoad() {\r\n    if (!this.triggerEl) {\r\n      console.warn('tooltip has no trigger element');\r\n      return;\r\n    }\r\n\r\n    this.uuid = createUuid();\r\n    this.triggerEl.setAttribute('tabindex', '0');\r\n    this.triggerEl.setAttribute('role', 'button');\r\n    this.triggerEl.setAttribute('aria-expanded', 'false');\r\n    this.triggerEl.setAttribute('aria-describedby', this.uuid);\r\n\r\n    // check if trigger element is inside another tooltip\r\n    this.isNestedTrigger = this.triggerEl.closest('dc-ui-tooltip') ? true : false;\r\n\r\n    // check if tooltip is inside another tooltip\r\n    const parent = this.el.closest('dc-ui-tooltip');\r\n    this.isNestedTooltip = !!parent?.contains(this.el);\r\n\r\n    // move tooltip to the end of the body if it's inside another tooltip\r\n    if (this.isNestedTooltip) {\r\n      const approot = document.querySelector('dc-ui-tooltip') || document.body;\r\n      approot.parentElement.appendChild(this.el);\r\n    }\r\n\r\n    // if trigger element is inside another tooltip, use timeout to initialize at the end of the queue\r\n    if (this.isNestedTrigger) {\r\n      this.timeoutID = setTimeout(() => {\r\n        addTriggerListeners(this);\r\n      }, 0);\r\n    } else {\r\n      addTriggerListeners(this);\r\n    }\r\n  }\r\n\r\n  componentDidRender() {\r\n    if (!this.triggerEl) {\r\n      return;\r\n    }\r\n\r\n    updateTooltipPosition(this);\r\n\r\n    if (this.content !== null) {\r\n      this.slotEl.remove();\r\n    } else {\r\n      this.contentEl.remove();\r\n    }\r\n\r\n    // check if inside slot is another tooltip\r\n    this.hasNestedTooltip = this.el.querySelector('dc-ui-tooltip') ? true : false;\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    if (!this.triggerEl) {\r\n      return;\r\n    }\r\n    removeDocumentListeners(this);\r\n    removeTriggerListeners(this);\r\n  }\r\n\r\n  onTriggerClick = (e: MouseEvent): void => {\r\n    e.stopPropagation();\r\n    if (this.trigger === 'click') {\r\n      toggleTooltip(this, e);\r\n    }\r\n  };\r\n\r\n  onTooltipClick = (e: MouseEvent): void => {\r\n    const target = e.target as HTMLElement;\r\n    if (target === e.currentTarget) {\r\n      e.stopPropagation();\r\n    }\r\n  };\r\n\r\n  onTriggerMouseOver = (): void => {\r\n    // add delay to prevent instant tooltip opening\r\n    setTimeout(() => {\r\n      openTooltip(this);\r\n    }, this.hoverDelay);\r\n  };\r\n\r\n  onTriggerMouseOut = (e: MouseEvent): void => {\r\n    // add delay to prevent tooltip from closing when moving from trigger to tooltip\r\n    setTimeout(() => {\r\n      closeTooltip(this, e);\r\n    }, this.hoverDelay);\r\n  };\r\n\r\n  onTriggerTouchStart = (e: MouseEvent): void => {\r\n    toggleTooltip(this, e);\r\n  };\r\n\r\n  onTriggerKeyDown = (e: KeyboardEvent): void => {\r\n    const { key } = e;\r\n    if (['SpaceBar', 'Enter', ' '].includes(key)) {\r\n      toggleTooltip(this, e);\r\n    }\r\n  };\r\n\r\n  render() {\r\n    if (!this.triggerEl) {\r\n      return;\r\n    }\r\n    const arrowOffset = 0;\r\n    injectCSS(\r\n      this.el,\r\n      createStyles,\r\n      this.placement,\r\n      arrowOffset,\r\n      this.maxWidth,\r\n      this.isNestedTrigger\r\n    );\r\n\r\n    return (\r\n      <Host>\r\n        <div\r\n          ref={(el) => (this.containerEl = el)}\r\n          id={this.uuid}\r\n          class={{\r\n            'dc-ui-tooltip__container': true,\r\n            'dc-ui-tooltip__container--open': this.open,\r\n            'dc-ui-tooltip__container--opening': this.opening,\r\n            'dc-ui-tooltip__container--closing': this.closing,\r\n          }}\r\n          role=\"tooltip\"\r\n          aria-hidden=\"true\"\r\n          hidden>\r\n          <div ref={(el) => (this.slotEl = el)}>\r\n            <slot></slot>\r\n          </div>\r\n          <dc-ui-text\r\n            ref={(el) => (this.contentEl = el)}\r\n            variant=\"mid-size-text\">\r\n            {this.content}\r\n          </dc-ui-text>\r\n          <div class=\"dc-ui-tooltip__arrow\"></div>\r\n        </div>\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n"],"names":["color","focusColor","redBrand01","redBrand02","redBrand03","turquoise01","turquoise02","turquoise03","turquoise04","turquoise05","turquoise06","grey01","grey02","grey03","grey04","grey05","grey06","grey07","grey08","grey09","grey10","green01","green02","green03","yellow01","yellow02","yellow03","red01","red02","red03","orange01","orange02","darkBlue01","darkBlue02","darkBlue03","white","black","ARROW_SIZE","TRANSITION_TIME","registeredTooltips","toggleTooltip","tooltip","event","opening","closing","open","closeTooltip","openTooltip","clearTimeout","timeoutID","updateTooltipPosition","addDocumentListeners","other","isNestedTrigger","closeTooltipInstantly","triggerEl","setAttribute","containerEl","removeAttribute","setTimeout","eventSrc","target","eventTargetisTrigger","contains","el","removeDocumentListeners","any","map","onDocumentClick","e","onDocumentKeydown","key","addTriggerListeners","addEventListener","onTooltipClick","trigger","onTriggerMouseOver","onTriggerMouseOut","onTriggerTouchStart","onTriggerClick","onTriggerKeyDown","length","document","onScrollOrResize","window","includes","push","index","indexOf","splice","removeEventListener","arrowOffset","actualPlacement","placement","originalPlacement","tooltipWidth","style","width","tooltipRect","getBoundingClientRect","triggerRect","targetXPos","targetYPos","targetPosition","checkAndAdjustPlacement","handleOutOfBoundsHorizontally","handleOutOfBoundsVertically","injectCSS","createStyles","maxWidth","transform","i","outOfBoundsHorizontally","outOfBoundsVerticallyIncludingScrolling","left","top","right","bottom","body","clientWidth","diff","triggerCenter","x","limit","clamp","height","tooltipCenter","Math","min","innerHeight","max","scrollDistFromTop","scrollY","scrollDistFromBottom","scrollHeight","val","arrowBorder","arrowBackground","arrowStyles","arrowBeforeStyles","borderTop","borderRight","borderBottom","borderLeft","arrowAfterStyles","nested","getCss","display","position","zIndex","pointerEvents","border","backgroundColor","filter","padding","opacity","transition","Object","assign","content","DcUiTooltip","stopPropagation","this","currentTarget","hoverDelay","show","Promise","resolve","hide","connectedCallback","shadowRoot","getRootNode","getElementById","triggerElement","componentWillLoad","console","warn","uuid","createUuid","closest","parent","isNestedTooltip","querySelector","parentElement","appendChild","componentDidRender","slotEl","remove","contentEl","hasNestedTooltip","disconnectedCallback","render","h","Host","ref","id","class","role","hidden","variant"],"sourceRoot":""}