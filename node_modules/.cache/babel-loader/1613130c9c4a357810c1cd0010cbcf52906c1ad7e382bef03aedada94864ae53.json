{"ast":null,"code":"import { r as registerInstance, h, a as Host, g as getElement } from './index-80864cdc.js';\nimport { i as injectCSS, g as getCss, c as createUuid } from './observeOptions-74693e66.js';\nimport { c as color } from './color-4d62bb24.js';\nconst ARROW_SIZE = 14; // width/height of the arrow (px)\nconst TOOLTIP_MARGIN = 16; // distance from the tooltip to the trigger element (px)\nconst VIEWPORT_MARGIN = 4; // how close the tooltip can come to the edge of the viewport (px)\nconst TRANSITION_TIME = 300; // tooltip fade-in transition time (ms)\nconst registeredTooltips = [];\n/**\n *\n * Toggles the tooltip's open state.\n *\n * @param tooltip\n */\nconst toggleTooltip = (tooltip, event) => {\n  if (tooltip.opening || tooltip.closing) {\n    return;\n  }\n  if (!tooltip.open) {\n    openTooltip(tooltip);\n  } else {\n    closeTooltip(tooltip, event);\n  }\n};\n/**\n *\n * Opens the tooltip.\n *\n * @param tooltip\n */\nconst openTooltip = tooltip => {\n  clearTimeout(tooltip.timeoutID);\n  updateTooltipPosition(tooltip);\n  addDocumentListeners(tooltip);\n  for (const other of registeredTooltips) {\n    if (other !== tooltip && !tooltip.isNestedTrigger) {\n      closeTooltipInstantly(other);\n    }\n  }\n  tooltip.triggerEl.setAttribute('aria-expanded', 'true');\n  tooltip.containerEl.removeAttribute('hidden');\n  tooltip.containerEl.removeAttribute('aria-hidden');\n  setTimeout(() => {\n    tooltip.opening = true;\n    tooltip.closing = false;\n  }, 0);\n  // I'd use an event listener on transitionend (with {once: true})\n  // but that seems to bug out in Firefox when rapidly opening/closing\n  tooltip.timeoutID = setTimeout(() => {\n    tooltip.opening = false;\n    tooltip.open = true;\n  }, TRANSITION_TIME);\n};\n/**\n *\n * Closes the tooltip.\n *\n * @param tooltip\n */\nconst closeTooltip = (tooltip, event) => {\n  const eventSrc = event === null || event === void 0 ? void 0 : event.target;\n  const eventTargetisTrigger = !!event && tooltip.triggerEl.contains(eventSrc);\n  // only close tooltip if no event was passed, or if the event target is not inside the tooltip\n  if (event && tooltip.el.contains(event.target)) {\n    return;\n  }\n  // if event target is tooltip trigger only close this tooltip\n  if (eventTargetisTrigger) {\n    clearTimeout(tooltip.timeoutID);\n    tooltip.closing = true;\n    tooltip.opening = false;\n    updateTooltipPosition(tooltip);\n    // I'd use an event listener on transitionend (with {once: true})\n    // but that seems to bug out in Firefox when rapidly opening/closing\n    tooltip.timeoutID = setTimeout(() => {\n      tooltip.closing = false;\n      tooltip.open = false;\n      tooltip.containerEl.setAttribute('hidden', 'hidden');\n      tooltip.containerEl.setAttribute('aria-hidden', 'true');\n      tooltip.triggerEl.setAttribute('aria-expanded', 'false');\n    }, TRANSITION_TIME);\n    removeDocumentListeners(tooltip);\n    return;\n  }\n  for (const any of registeredTooltips) {\n    clearTimeout(any.timeoutID);\n    any.closing = true;\n    any.opening = false;\n    updateTooltipPosition(any);\n    if (any.isNestedTrigger) {\n      any.closing = false;\n      any.open = false;\n      any.containerEl.setAttribute('hidden', 'hidden');\n      any.containerEl.setAttribute('aria-hidden', 'true');\n      any.triggerEl.setAttribute('aria-expanded', 'false');\n    } else {\n      // I'd use an event listener on transitionend (with {once: true})\n      // but that seems to bug out in Firefox when rapidly opening/closing\n      any.timeoutID = setTimeout(() => {\n        any.closing = false;\n        any.open = false;\n        any.containerEl.setAttribute('hidden', 'hidden');\n        any.containerEl.setAttribute('aria-hidden', 'true');\n        any.triggerEl.setAttribute('aria-expanded', 'false');\n      }, TRANSITION_TIME);\n    }\n  }\n  registeredTooltips.map(tooltip => {\n    removeDocumentListeners(tooltip);\n  });\n};\n/**\n *\n * Closes the tooltip instantly.\n *\n * @param tooltip\n */\nconst closeTooltipInstantly = tooltip => {\n  clearTimeout(tooltip.timeoutID);\n  removeDocumentListeners(tooltip);\n  updateTooltipPosition(tooltip);\n  tooltip.closing = false;\n  tooltip.open = false;\n  tooltip.containerEl.setAttribute('hidden', 'hidden');\n  tooltip.containerEl.setAttribute('aria-hidden', 'true');\n  tooltip.triggerEl.setAttribute('aria-expanded', 'false');\n};\n/**\n * Closes all tooltips.\n *\n * Called on document click.\n */\nconst onDocumentClick = e => {\n  for (const tooltip of registeredTooltips) {\n    closeTooltip(tooltip, e);\n  }\n};\n/**\n * Closes all tooltips if the Escape key is pressed.\n *\n * Called on document keydown.\n */\nconst onDocumentKeydown = e => {\n  if (e.key === 'Escape') {\n    for (const tooltip of registeredTooltips) {\n      closeTooltip(tooltip, e);\n    }\n  }\n};\n/**\n * Adds event listeners to toggle the tooltip.\n *\n * @param tooltip\n */\nconst addTriggerListeners = tooltip => {\n  tooltip.el.addEventListener('click', tooltip.onTooltipClick);\n  if (tooltip.trigger === 'hover') {\n    tooltip.triggerEl.addEventListener('focus', tooltip.onTriggerMouseOver);\n    tooltip.triggerEl.addEventListener('mouseover', tooltip.onTriggerMouseOver);\n    tooltip.triggerEl.addEventListener('blur', tooltip.onTriggerMouseOut);\n    tooltip.triggerEl.addEventListener('mouseout', tooltip.onTriggerMouseOut);\n    tooltip.triggerEl.addEventListener('touchstart', tooltip.onTriggerTouchStart);\n  } else {\n    tooltip.triggerEl.addEventListener('click', tooltip.onTriggerClick);\n    tooltip.triggerEl.addEventListener('keydown', tooltip.onTriggerKeyDown);\n  }\n};\n/**\n * Removes event listeners to toggle the tooltip.\n *\n * @param tooltip\n */\nconst removeTriggerListeners = tooltip => {\n  tooltip.el.removeEventListener('click', tooltip.onTooltipClick);\n  if (tooltip.trigger === 'hover') {\n    tooltip.triggerEl.removeEventListener('focus', tooltip.onTriggerMouseOver);\n    tooltip.triggerEl.removeEventListener('mouseover', tooltip.onTriggerMouseOver);\n    tooltip.triggerEl.removeEventListener('blur', tooltip.onTriggerMouseOut);\n    tooltip.triggerEl.removeEventListener('mouseout', tooltip.onTriggerMouseOut);\n    tooltip.triggerEl.removeEventListener('touchstart', tooltip.onTriggerTouchStart);\n  } else {\n    tooltip.triggerEl.removeEventListener('click', tooltip.onTriggerClick);\n    tooltip.triggerEl.removeEventListener('keydown', tooltip.onTriggerKeyDown);\n  }\n};\n/**\n * Adds event listeners to the document if they don't already exist.\n *\n * Also adds the tooltip to the list of registered tooltips.\n *\n * @param tooltip\n */\nconst addDocumentListeners = tooltip => {\n  if (registeredTooltips.length === 0) {\n    document.addEventListener('scroll', onScrollOrResize);\n    window.addEventListener('resize', onScrollOrResize);\n    document.addEventListener('click', onDocumentClick);\n    document.addEventListener('keydown', onDocumentKeydown);\n  }\n  if (!registeredTooltips.includes(tooltip)) {\n    registeredTooltips.push(tooltip);\n  }\n};\n/**\n * Removes event listeners from the document if they're no longer needed.\n *\n * Also removes the tooltip from the list of registered tooltips.\n *\n * @param tooltip\n */\nconst removeDocumentListeners = tooltip => {\n  const index = registeredTooltips.indexOf(tooltip);\n  if (index > -1) {\n    registeredTooltips.splice(index, 1);\n  }\n  if (registeredTooltips.length === 0) {\n    document.removeEventListener('scroll', onScrollOrResize);\n    window.removeEventListener('resize', onScrollOrResize);\n    document.removeEventListener('click', onDocumentClick);\n    document.removeEventListener('keydown', onDocumentKeydown);\n  }\n};\n/**\n * Updates the positions of all registered tooltips.\n *\n * Called on document scroll or window resize.\n */\nconst onScrollOrResize = () => {\n  for (const tooltip of registeredTooltips) {\n    updateTooltipPosition(tooltip);\n  }\n};\n/**\n * Updates the position of a tooltip.\n *\n * @param tooltip\n */\nconst updateTooltipPosition = tooltip => {\n  let arrowOffset = 0;\n  let actualPlacement = tooltip.placement;\n  const originalPlacement = tooltip.placement;\n  let tooltipWidth = null;\n  tooltip.el.style.width = null;\n  let tooltipRect = tooltip.el.getBoundingClientRect();\n  const triggerRect = tooltip.triggerEl.getBoundingClientRect();\n  // calculate \"desired\" positions\n  let [targetXPos, targetYPos] = targetPosition(tooltipRect, triggerRect, actualPlacement);\n  // if the tooltip is out of bounds, adjust the placement\n  [targetXPos, targetYPos, actualPlacement] = checkAndAdjustPlacement(targetXPos, targetYPos, actualPlacement, originalPlacement, tooltipRect, triggerRect);\n  // for top and bottom placements: if it's still out of bounds, adjust the position, arrow offset and width\n  if (['top', 'bottom'].includes(actualPlacement)) {\n    [targetXPos, targetYPos, arrowOffset, tooltipWidth] = handleOutOfBoundsHorizontally(targetXPos, targetYPos, tooltipRect, triggerRect);\n    // apply the calculated width\n    tooltip.el.style.width = tooltipWidth === null ? null : `${tooltipWidth}px`;\n    // the width change may have changed the height too, so recalculate the target Y position\n    tooltipRect = tooltip.el.getBoundingClientRect();\n    targetYPos = targetPosition(tooltipRect, triggerRect, actualPlacement)[1];\n  }\n  // for left and right placements: if it's still out of bounds, adjust the position and arrow offset\n  if (['left', 'right'].includes(actualPlacement)) {\n    [targetYPos, arrowOffset] = handleOutOfBoundsVertically(targetYPos, tooltipRect, triggerRect);\n  }\n  // re-inject the CSS to update the placement and arrow position\n  injectCSS(tooltip.el, createStyles, actualPlacement, arrowOffset, tooltip.maxWidth, tooltip.isNestedTrigger);\n  // apply the calculated position\n  tooltip.el.style.transform = `translate(${targetXPos}px, ${targetYPos}px)`;\n};\n/**\n * Changes the placement of a tooltip if it's outside the viewport bounds.\n *\n * If there is no placement that works, it falls back to either \"top\" or \"bottom\".\n *\n * @param targetXPos\n * @param targetYPos\n * @param placement\n * @param originalPlacement\n * @param tooltipRect\n * @param triggerRect\n */\nconst checkAndAdjustPlacement = (targetXPos, targetYPos, placement, originalPlacement, tooltipRect, triggerRect) => {\n  // if the tooltip is out of bounds, try changing the placement (2 tries)\n  for (let i = 0; i <= 1; i++) {\n    // left/right only needs to change to top/bottom if it's out of bounds horizontally,\n    // top/bottom  only needs to change to left/right if it's out of bounds vertically\n    // other kinds of overflow are handled later\n    if (['left', 'right'].includes(placement) && outOfBoundsHorizontally(tooltipRect, targetXPos) || ['top', 'bottom'].includes(placement) && outOfBoundsVerticallyIncludingScrolling(tooltipRect, targetYPos)) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      placement = {\n        left: 'top',\n        top: 'right',\n        right: 'bottom',\n        bottom: 'left'\n      }[placement];\n      [targetXPos, targetYPos] = targetPosition(tooltipRect, triggerRect, placement);\n    }\n  }\n  // if it's *still* out of bounds, at least make sure it's on the top or bottom\n  if (outOfBoundsHorizontally(tooltipRect, targetXPos) || outOfBoundsVerticallyIncludingScrolling(tooltipRect, targetYPos)) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    placement = {\n      left: 'top',\n      top: 'top',\n      right: 'bottom',\n      bottom: 'bottom'\n    }[originalPlacement];\n    [targetXPos, targetYPos] = targetPosition(tooltipRect, triggerRect, placement);\n  }\n  // if it's *still* out of bounds vertically, then change top to bottom and vice versa\n  if (outOfBoundsVerticallyIncludingScrolling(tooltipRect, targetYPos)) {\n    placement = placement === 'top' ? 'bottom' : 'top';\n    [targetXPos, targetYPos] = targetPosition(tooltipRect, triggerRect, placement);\n  }\n  return [targetXPos, targetYPos, placement];\n};\n/**\n * Changes the position, width and arrow position of a tooltip if it's outside the viewport horizontally.\n *\n * This uses different logic than handleOutOfBoundsVertically,\n * because horizontal and vertical overflow are different use cases.\n *\n * @param targetXPos\n * @param targetYPos\n * @param tooltipRect\n * @param triggerRect\n */\nconst handleOutOfBoundsHorizontally = (targetXPos, targetYPos, tooltipRect, triggerRect) => {\n  let tooltipWidth = null;\n  // if it's out of bounds on the left,\n  // move it right, then check if it's out of bounds on the right and cut off the excess width\n  if (targetXPos < VIEWPORT_MARGIN) {\n    targetXPos = VIEWPORT_MARGIN;\n    if (targetXPos + tooltipRect.width >= document.body.clientWidth - VIEWPORT_MARGIN) {\n      const diff = tooltipRect.width - (document.body.clientWidth - 2 * VIEWPORT_MARGIN);\n      tooltipWidth = tooltipRect.width - diff;\n    }\n  }\n  // if it's out of bounds on the right,\n  // move it left, then check if it's out of bounds on the left and cut off the excess width\n  if (targetXPos + tooltipRect.width >= document.body.clientWidth - VIEWPORT_MARGIN) {\n    targetXPos = document.body.clientWidth - tooltipRect.width - VIEWPORT_MARGIN;\n    if (targetXPos < VIEWPORT_MARGIN) {\n      const diff = tooltipRect.width - (document.body.clientWidth - 2 * VIEWPORT_MARGIN);\n      targetXPos = targetXPos + diff;\n      tooltipWidth = tooltipRect.width - diff;\n    }\n  }\n  // point the arrow to the center of the trigger\n  const width = tooltipWidth !== null ? tooltipWidth : tooltipRect.width;\n  const triggerCenter = triggerRect.x + triggerRect.width / 2;\n  const tooltipCenter = targetXPos + width / 2;\n  const targetOffset = triggerCenter - tooltipCenter;\n  // constrain the arrow to be within the tooltip\n  const limit = (width - ARROW_SIZE) / 2;\n  const arrowOffset = clamp(targetOffset, -limit, limit);\n  return [targetXPos, targetYPos, arrowOffset, tooltipWidth];\n};\n/**\n * Changes the position and arrow position of a tooltip if it's outside the viewport vertically.\n *\n * This uses different logic than handleOutOfBoundsHorizontally,\n * because horizontal and vertical overflow are different use cases.\n *\n * @param targetYPos\n * @param tooltipRect\n * @param triggerRect\n */\nconst handleOutOfBoundsVertically = (targetYPos, tooltipRect, triggerRect) => {\n  let arrowOffset = 0;\n  // case 1: trigger is off-screen (so far up that the tooltip has to move off-screen with it)\n  if (triggerRect.bottom < VIEWPORT_MARGIN) {\n    // make the tooltip move with the bottom of the trigger\n    targetYPos = triggerRect.bottom;\n    // put the arrow at the very top\n    arrowOffset = (ARROW_SIZE - tooltipRect.height) / 2;\n  }\n  // case 2: trigger is so far up that the tooltip can't be where it wants to (but can still be visible)\n  else if (targetYPos < VIEWPORT_MARGIN) {\n    // make the tooltip stick to the top of the viewport\n    targetYPos = VIEWPORT_MARGIN;\n    // point the arrow to the center of the trigger (but no further down than the center of the tooltip)\n    const tooltipCenter = targetYPos + tooltipRect.height / 2;\n    const triggerCenter = triggerRect.top + triggerRect.height / 2;\n    const targetArrowPos = Math.min(triggerCenter, tooltipCenter);\n    arrowOffset = targetArrowPos - tooltipCenter;\n  }\n  // case 3: trigger is off-screen (so far down that the tooltip has to move off-screen with it)\n  else if (triggerRect.top > window.innerHeight - VIEWPORT_MARGIN) {\n    // make the tooltip move with the top of the trigger\n    targetYPos = triggerRect.top - tooltipRect.height;\n    // put the arrow at the very bottom\n    arrowOffset = (tooltipRect.height - ARROW_SIZE) / 2;\n  }\n  // case 4: trigger is so far down that the tooltip can't be where it wants to (but can still be visible)\n  else if (targetYPos + tooltipRect.height > window.innerHeight - VIEWPORT_MARGIN) {\n    // make the tooltip stick to the bottom of the viewport\n    targetYPos = window.innerHeight - VIEWPORT_MARGIN - tooltipRect.height;\n    // point the arrow to the center of the trigger (but no further up than the center of the tooltip)\n    const tooltipCenter = targetYPos + tooltipRect.height / 2;\n    const triggerCenter = triggerRect.top + triggerRect.height / 2;\n    const targetArrowPos = Math.max(triggerCenter, tooltipCenter);\n    arrowOffset = targetArrowPos - tooltipCenter;\n  }\n  // constrain the arrow to be within the tooltip\n  const limit = (tooltipRect.height - ARROW_SIZE) / 2;\n  arrowOffset = clamp(arrowOffset, -limit, limit);\n  return [targetYPos, arrowOffset];\n};\n/**\n * Checks if a tooltip is outside the viewport horizontally (left or right).\n *\n * @param tooltipRect\n * @param targetXPos\n */\nconst outOfBoundsHorizontally = (tooltipRect, targetXPos) => {\n  return targetXPos < VIEWPORT_MARGIN || targetXPos + tooltipRect.width > document.body.clientWidth - VIEWPORT_MARGIN;\n};\n/**\n * Checks if a tooltip is outside the viewport vertically (top or bottom), taking scrolling into account.\n *\n * If the tooltip is outside the viewport, but there's room to scroll it back into view,\n * it doesn't count as \"outside the viewport\".\n *\n * @param tooltipRect\n * @param targetYPos\n */\nconst outOfBoundsVerticallyIncludingScrolling = (tooltipRect, targetYPos) => {\n  const scrollDistFromTop = window.scrollY;\n  const scrollDistFromBottom = document.body.scrollHeight - window.innerHeight - window.scrollY;\n  return targetYPos < VIEWPORT_MARGIN - scrollDistFromTop || targetYPos + tooltipRect.height > window.innerHeight + scrollDistFromBottom - VIEWPORT_MARGIN;\n};\n/**\n *\n * Calculates the tooltip position given the trigger element and the tooltip placement.\n *\n * Note that this is just the \"desired\" position.\n * It can (and will) be changed by the calling function if it makes the tooltip go out of bounds.\n *\n * @param tooltipRect\n * @param triggerRect\n * @param placement\n */\nconst targetPosition = (tooltipRect, triggerRect, placement) => {\n  const targetXPos = {\n    top: triggerRect.left + triggerRect.width / 2 - tooltipRect.width / 2,\n    right: triggerRect.right + TOOLTIP_MARGIN,\n    bottom: triggerRect.left + triggerRect.width / 2 - tooltipRect.width / 2,\n    left: triggerRect.left - tooltipRect.width - TOOLTIP_MARGIN\n  }[placement];\n  const targetYPos = {\n    top: triggerRect.top - tooltipRect.height - TOOLTIP_MARGIN,\n    right: triggerRect.top + triggerRect.height / 2 - tooltipRect.height / 2,\n    bottom: triggerRect.bottom + TOOLTIP_MARGIN,\n    left: triggerRect.top + triggerRect.height / 2 - tooltipRect.height / 2\n  }[placement];\n  return [targetXPos, targetYPos];\n};\nfunction clamp(val, min, max) {\n  return val > max ? max : val < min ? min : val;\n}\nconst arrowBorder = `${ARROW_SIZE / 2}px solid ${color.grey03}`;\nconst arrowBackground = `${ARROW_SIZE / 2}px solid ${color.white}`;\nfunction arrowStyles(placement, arrowOffset) {\n  return {\n    top: {\n      bottom: '0',\n      left: '50%',\n      transform: `translateX(-50%) translateX(${arrowOffset}px)`\n    },\n    right: {\n      left: '0',\n      top: '50%',\n      transform: `translateY(-50%) translateY(${arrowOffset}px)`\n    },\n    bottom: {\n      top: '0',\n      left: '50%',\n      transform: `translateX(-50%) translateX(${arrowOffset}px)`\n    },\n    left: {\n      right: '0',\n      top: '50%',\n      transform: `translateY(-50%) translateY(${arrowOffset}px)`\n    }\n  }[placement];\n}\nfunction arrowBeforeStyles(placement) {\n  return {\n    top: {\n      bottom: `-${ARROW_SIZE + 1}px`,\n      borderTop: arrowBorder\n    },\n    right: {\n      left: `-${ARROW_SIZE + 1}px`,\n      borderRight: arrowBorder\n    },\n    bottom: {\n      top: `-${ARROW_SIZE + 1}px`,\n      borderBottom: arrowBorder\n    },\n    left: {\n      right: `-${ARROW_SIZE + 1}px`,\n      borderLeft: arrowBorder\n    }\n  }[placement];\n}\nfunction arrowAfterStyles(placement) {\n  return {\n    top: {\n      bottom: `-${ARROW_SIZE}px`,\n      borderTop: arrowBackground\n    },\n    right: {\n      left: `-${ARROW_SIZE}px`,\n      borderRight: arrowBackground\n    },\n    bottom: {\n      top: `-${ARROW_SIZE}px`,\n      borderBottom: arrowBackground\n    },\n    left: {\n      right: `-${ARROW_SIZE}px`,\n      borderLeft: arrowBackground\n    }\n  }[placement];\n}\nconst createStyles = (placement, arrowOffset, maxWidth, nested) => {\n  const styles = getCss({\n    '@global': {\n      ':host': {\n        display: 'block',\n        width: 'fit-content',\n        maxWidth: `${maxWidth}px`,\n        position: 'fixed',\n        top: '0',\n        left: '0',\n        zIndex: nested ? '10000' : '9999',\n        pointerEvents: 'none'\n      },\n      '.dc-ui-tooltip__container': {\n        position: 'relative',\n        border: `1px solid ${color.grey02}`,\n        backgroundColor: color.white,\n        // using drop-shadow instead of box-shadow adds shadow to the arrow as well\n        // note: for drop-shadow, the blur radius needs to be halved (6px --> 3px) to give the same result as box-shadow\n        filter: 'drop-shadow(0 2px 3px rgba(0, 0, 0, 0.3))',\n        padding: '1rem',\n        opacity: 0,\n        pointerEvents: 'none',\n        '&--opening, &--closing': {\n          transition: `opacity ${TRANSITION_TIME}ms`\n        },\n        '&--opening, &--open': {\n          opacity: 1,\n          pointerEvents: 'initial'\n        },\n        '&--closing': {\n          opacity: 0\n        }\n      },\n      '.dc-ui-tooltip__arrow': Object.assign(Object.assign({\n        position: 'absolute',\n        width: `${ARROW_SIZE}px`,\n        height: `${ARROW_SIZE}px`\n      }, arrowStyles(placement, arrowOffset)), {\n        '&::before, &::after': {\n          content: '\"\"',\n          position: 'absolute',\n          width: '0',\n          height: '0',\n          border: `${ARROW_SIZE / 2}px solid transparent`\n        },\n        '&::before': Object.assign({}, arrowBeforeStyles(placement)),\n        '&::after': Object.assign({}, arrowAfterStyles(placement))\n      })\n    }\n  });\n  return styles;\n};\nconst DcUiTooltip = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.onTriggerClick = e => {\n      e.stopPropagation();\n      if (this.trigger === 'click') {\n        toggleTooltip(this, e);\n      }\n    };\n    this.onTooltipClick = e => {\n      const target = e.target;\n      if (target === e.currentTarget) {\n        e.stopPropagation();\n      }\n    };\n    this.onTriggerMouseOver = () => {\n      // add delay to prevent instant tooltip opening\n      setTimeout(() => {\n        openTooltip(this);\n      }, this.hoverDelay);\n    };\n    this.onTriggerMouseOut = e => {\n      // add delay to prevent tooltip from closing when moving from trigger to tooltip\n      setTimeout(() => {\n        closeTooltip(this, e);\n      }, this.hoverDelay);\n    };\n    this.onTriggerTouchStart = e => {\n      toggleTooltip(this, e);\n    };\n    this.onTriggerKeyDown = e => {\n      const {\n        key\n      } = e;\n      if (['SpaceBar', 'Enter', ' '].includes(key)) {\n        toggleTooltip(this, e);\n      }\n    };\n    this.placement = 'top';\n    this.content = null;\n    this.trigger = 'hover';\n    this.triggerElement = '';\n    this.maxWidth = 500;\n    this.hoverDelay = 0;\n    this.open = false;\n    this.opening = false;\n    this.closing = false;\n  }\n  show() {\n    return new Promise(resolve => {\n      openTooltip(this);\n      resolve(true);\n    });\n  }\n  hide() {\n    return new Promise(resolve => {\n      closeTooltip(this);\n      resolve(true);\n    });\n  }\n  connectedCallback() {\n    // get reference of the root element\n    const shadowRoot = this.el.getRootNode();\n    // search for trigger element. Either in light DOM or in shadow DOM\n    this.triggerEl = shadowRoot.getElementById(this.triggerElement);\n  }\n  componentWillLoad() {\n    if (!this.triggerEl) {\n      console.warn('tooltip has no trigger element');\n      return;\n    }\n    this.uuid = createUuid();\n    this.triggerEl.setAttribute('tabindex', '0');\n    this.triggerEl.setAttribute('role', 'button');\n    this.triggerEl.setAttribute('aria-expanded', 'false');\n    this.triggerEl.setAttribute('aria-describedby', this.uuid);\n    // check if trigger element is inside another tooltip\n    this.isNestedTrigger = this.triggerEl.closest('dc-ui-tooltip') ? true : false;\n    // check if tooltip is inside another tooltip\n    const parent = this.el.closest('dc-ui-tooltip');\n    this.isNestedTooltip = !!(parent === null || parent === void 0 ? void 0 : parent.contains(this.el));\n    // move tooltip to the end of the body if it's inside another tooltip\n    if (this.isNestedTooltip) {\n      const approot = document.querySelector('dc-ui-tooltip') || document.body;\n      approot.parentElement.appendChild(this.el);\n    }\n    // if trigger element is inside another tooltip, use timeout to initialize at the end of the queue\n    if (this.isNestedTrigger) {\n      this.timeoutID = setTimeout(() => {\n        addTriggerListeners(this);\n      }, 0);\n    } else {\n      addTriggerListeners(this);\n    }\n  }\n  componentDidRender() {\n    if (!this.triggerEl) {\n      return;\n    }\n    updateTooltipPosition(this);\n    if (this.content !== null) {\n      this.slotEl.remove();\n    } else {\n      this.contentEl.remove();\n    }\n    // check if inside slot is another tooltip\n    this.hasNestedTooltip = this.el.querySelector('dc-ui-tooltip') ? true : false;\n  }\n  disconnectedCallback() {\n    if (!this.triggerEl) {\n      return;\n    }\n    removeDocumentListeners(this);\n    removeTriggerListeners(this);\n  }\n  render() {\n    if (!this.triggerEl) {\n      return;\n    }\n    const arrowOffset = 0;\n    injectCSS(this.el, createStyles, this.placement, arrowOffset, this.maxWidth, this.isNestedTrigger);\n    return h(Host, null, h(\"div\", {\n      ref: el => this.containerEl = el,\n      id: this.uuid,\n      class: {\n        'dc-ui-tooltip__container': true,\n        'dc-ui-tooltip__container--open': this.open,\n        'dc-ui-tooltip__container--opening': this.opening,\n        'dc-ui-tooltip__container--closing': this.closing\n      },\n      role: \"tooltip\",\n      \"aria-hidden\": \"true\",\n      hidden: true\n    }, h(\"div\", {\n      ref: el => this.slotEl = el\n    }, h(\"slot\", null)), h(\"dc-ui-text\", {\n      ref: el => this.contentEl = el,\n      variant: \"mid-size-text\"\n    }, this.content), h(\"div\", {\n      class: \"dc-ui-tooltip__arrow\"\n    })));\n  }\n  get el() {\n    return getElement(this);\n  }\n};\nexport { DcUiTooltip as dc_ui_tooltip };","map":{"version":3,"names":["ARROW_SIZE","TOOLTIP_MARGIN","VIEWPORT_MARGIN","TRANSITION_TIME","registeredTooltips","toggleTooltip","tooltip","event","opening","closing","open","openTooltip","closeTooltip","clearTimeout","timeoutID","updateTooltipPosition","addDocumentListeners","other","isNestedTrigger","closeTooltipInstantly","triggerEl","setAttribute","containerEl","removeAttribute","setTimeout","eventSrc","target","eventTargetisTrigger","contains","el","removeDocumentListeners","any","map","onDocumentClick","e","onDocumentKeydown","key","addTriggerListeners","addEventListener","onTooltipClick","trigger","onTriggerMouseOver","onTriggerMouseOut","onTriggerTouchStart","onTriggerClick","onTriggerKeyDown","removeTriggerListeners","removeEventListener","length","document","onScrollOrResize","window","includes","push","index","indexOf","splice","arrowOffset","actualPlacement","placement","originalPlacement","tooltipWidth","style","width","tooltipRect","getBoundingClientRect","triggerRect","targetXPos","targetYPos","targetPosition","checkAndAdjustPlacement","handleOutOfBoundsHorizontally","handleOutOfBoundsVertically","injectCSS","createStyles","maxWidth","transform","i","outOfBoundsHorizontally","outOfBoundsVerticallyIncludingScrolling","left","top","right","bottom","body","clientWidth","diff","triggerCenter","x","tooltipCenter","targetOffset","limit","clamp","height","targetArrowPos","Math","min","innerHeight","max","scrollDistFromTop","scrollY","scrollDistFromBottom","scrollHeight","val","arrowBorder","color","grey03","arrowBackground","white","arrowStyles","arrowBeforeStyles","borderTop","borderRight","borderBottom","borderLeft","arrowAfterStyles","nested","styles","getCss","display","position","zIndex","pointerEvents","border","grey02","backgroundColor","filter","padding","opacity","transition","Object","assign","content","DcUiTooltip","stopPropagation","currentTarget","hoverDelay","show","Promise","resolve","hide","connectedCallback","shadowRoot","getRootNode","getElementById","triggerElement","componentWillLoad","console","warn","uuid","createUuid","closest","parent","isNestedTooltip","approot","querySelector","parentElement","appendChild","componentDidRender","slotEl","remove","contentEl","hasNestedTooltip","disconnectedCallback","render","h","Host","ref","id","class","role","hidden","variant"],"sources":["C:\\Users\\LGD1KOR\\Desktop\\react\\my-app\\node_modules\\@boschrexroth\\nextgen-web-ui-toolkit\\dist\\esm\\src\\components\\dc-ui-tooltip\\tooltip-utils.ts","C:\\Users\\LGD1KOR\\Desktop\\react\\my-app\\node_modules\\@boschrexroth\\nextgen-web-ui-toolkit\\dist\\esm\\src\\components\\dc-ui-tooltip\\tooltip-styles.ts","C:\\Users\\LGD1KOR\\Desktop\\react\\my-app\\node_modules\\@boschrexroth\\nextgen-web-ui-toolkit\\dist\\esm\\src\\components\\dc-ui-tooltip\\dc-ui-tooltip.tsx"],"sourcesContent":["import { DcUiTooltip } from './dc-ui-tooltip';\r\nimport { injectCSS } from '../../utils';\r\nimport { createStyles } from './tooltip-styles';\r\n\r\nexport const ARROW_SIZE = 14; // width/height of the arrow (px)\r\nexport const TOOLTIP_MARGIN = 16; // distance from the tooltip to the trigger element (px)\r\nexport const VIEWPORT_MARGIN = 4; // how close the tooltip can come to the edge of the viewport (px)\r\nexport const TRANSITION_TIME = 300; // tooltip fade-in transition time (ms)\r\n\r\nexport const TOOLTIP_PLACEMENTS = ['top', 'bottom', 'left', 'right'] as const;\r\nexport type TTooltipPlacement = typeof TOOLTIP_PLACEMENTS[number];\r\n\r\nexport const TOOLTIP_TRIGGERS = ['click', 'hover'] as const;\r\nexport type TTooltipTrigger = typeof TOOLTIP_TRIGGERS[number];\r\n\r\nexport const registeredTooltips: DcUiTooltip[] = [];\r\n\r\n/**\r\n *\r\n * Toggles the tooltip's open state.\r\n *\r\n * @param tooltip\r\n */\r\nexport const toggleTooltip = (tooltip: DcUiTooltip, event: Event): void => {\r\n  if (tooltip.opening || tooltip.closing) {\r\n    return;\r\n  }\r\n  if (!tooltip.open) {\r\n    openTooltip(tooltip);\r\n  } else {\r\n    closeTooltip(tooltip, event);\r\n  }\r\n};\r\n\r\n/**\r\n *\r\n * Opens the tooltip.\r\n *\r\n * @param tooltip\r\n */\r\nexport const openTooltip = (tooltip: DcUiTooltip): void => {\r\n  clearTimeout(tooltip.timeoutID);\r\n  updateTooltipPosition(tooltip);\r\n  addDocumentListeners(tooltip);\r\n\r\n  for (const other of registeredTooltips) {\r\n    if (other !== tooltip && !tooltip.isNestedTrigger) {\r\n      closeTooltipInstantly(other);\r\n    }\r\n  }\r\n\r\n  tooltip.triggerEl.setAttribute('aria-expanded', 'true');\r\n  tooltip.containerEl.removeAttribute('hidden');\r\n  tooltip.containerEl.removeAttribute('aria-hidden');\r\n  setTimeout(() => {\r\n    tooltip.opening = true;\r\n    tooltip.closing = false;\r\n  }, 0);\r\n\r\n  // I'd use an event listener on transitionend (with {once: true})\r\n  // but that seems to bug out in Firefox when rapidly opening/closing\r\n  tooltip.timeoutID = setTimeout(() => {\r\n    tooltip.opening = false;\r\n    tooltip.open = true;\r\n  }, TRANSITION_TIME);\r\n};\r\n\r\n/**\r\n *\r\n * Closes the tooltip.\r\n *\r\n * @param tooltip\r\n */\r\nexport const closeTooltip = (tooltip: DcUiTooltip, event?: Event): void => {\r\n  const eventSrc = event?.target as HTMLElement;\r\n  const eventTargetisTrigger = !!event && tooltip.triggerEl.contains(eventSrc);\r\n\r\n  // only close tooltip if no event was passed, or if the event target is not inside the tooltip\r\n  if (event && tooltip.el.contains(event.target as Node)) {\r\n    return;\r\n  }\r\n\r\n  // if event target is tooltip trigger only close this tooltip\r\n  if (eventTargetisTrigger) {\r\n    clearTimeout(tooltip.timeoutID);\r\n    tooltip.closing = true;\r\n    tooltip.opening = false;\r\n    updateTooltipPosition(tooltip);\r\n\r\n    // I'd use an event listener on transitionend (with {once: true})\r\n    // but that seems to bug out in Firefox when rapidly opening/closing\r\n    tooltip.timeoutID = setTimeout(() => {\r\n      tooltip.closing = false;\r\n      tooltip.open = false;\r\n      tooltip.containerEl.setAttribute('hidden', 'hidden');\r\n      tooltip.containerEl.setAttribute('aria-hidden', 'true');\r\n      tooltip.triggerEl.setAttribute('aria-expanded', 'false');\r\n    }, TRANSITION_TIME);\r\n    removeDocumentListeners(tooltip);\r\n    return;\r\n  }\r\n\r\n  for (const any of registeredTooltips) {\r\n    clearTimeout(any.timeoutID);\r\n    any.closing = true;\r\n    any.opening = false;\r\n    updateTooltipPosition(any);\r\n\r\n    if (any.isNestedTrigger) {\r\n      any.closing = false;\r\n      any.open = false;\r\n      any.containerEl.setAttribute('hidden', 'hidden');\r\n      any.containerEl.setAttribute('aria-hidden', 'true');\r\n      any.triggerEl.setAttribute('aria-expanded', 'false');\r\n    } else {\r\n      // I'd use an event listener on transitionend (with {once: true})\r\n      // but that seems to bug out in Firefox when rapidly opening/closing\r\n      any.timeoutID = setTimeout(() => {\r\n        any.closing = false;\r\n        any.open = false;\r\n        any.containerEl.setAttribute('hidden', 'hidden');\r\n        any.containerEl.setAttribute('aria-hidden', 'true');\r\n        any.triggerEl.setAttribute('aria-expanded', 'false');\r\n      }, TRANSITION_TIME);\r\n    }\r\n  }\r\n\r\n  registeredTooltips.map((tooltip) => {\r\n    removeDocumentListeners(tooltip);\r\n  });\r\n};\r\n\r\n/**\r\n *\r\n * Closes the tooltip instantly.\r\n *\r\n * @param tooltip\r\n */\r\nexport const closeTooltipInstantly = (tooltip: DcUiTooltip): void => {\r\n  clearTimeout(tooltip.timeoutID);\r\n  removeDocumentListeners(tooltip);\r\n  updateTooltipPosition(tooltip);\r\n  tooltip.closing = false;\r\n  tooltip.open = false;\r\n  tooltip.containerEl.setAttribute('hidden', 'hidden');\r\n  tooltip.containerEl.setAttribute('aria-hidden', 'true');\r\n  tooltip.triggerEl.setAttribute('aria-expanded', 'false');\r\n};\r\n\r\n/**\r\n * Closes all tooltips.\r\n *\r\n * Called on document click.\r\n */\r\nexport const onDocumentClick = (e: MouseEvent): void => {\r\n  for (const tooltip of registeredTooltips) {\r\n    closeTooltip(tooltip, e);\r\n  }\r\n};\r\n\r\n/**\r\n * Closes all tooltips if the Escape key is pressed.\r\n *\r\n * Called on document keydown.\r\n */\r\nexport const onDocumentKeydown = (e: KeyboardEvent): void => {\r\n  if (e.key === 'Escape') {\r\n    for (const tooltip of registeredTooltips) {\r\n      closeTooltip(tooltip, e);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Adds event listeners to toggle the tooltip.\r\n *\r\n * @param tooltip\r\n */\r\nexport const addTriggerListeners = (tooltip: DcUiTooltip): void => {\r\n  tooltip.el.addEventListener('click', tooltip.onTooltipClick);\r\n\r\n  if (tooltip.trigger === 'hover') {\r\n    tooltip.triggerEl.addEventListener('focus', tooltip.onTriggerMouseOver);\r\n    tooltip.triggerEl.addEventListener('mouseover', tooltip.onTriggerMouseOver);\r\n    tooltip.triggerEl.addEventListener('blur', tooltip.onTriggerMouseOut);\r\n    tooltip.triggerEl.addEventListener('mouseout', tooltip.onTriggerMouseOut);\r\n    tooltip.triggerEl.addEventListener('touchstart', tooltip.onTriggerTouchStart);\r\n  } else {\r\n    tooltip.triggerEl.addEventListener('click', tooltip.onTriggerClick);\r\n    tooltip.triggerEl.addEventListener('keydown', tooltip.onTriggerKeyDown);\r\n  }\r\n};\r\n\r\n/**\r\n * Removes event listeners to toggle the tooltip.\r\n *\r\n * @param tooltip\r\n */\r\nexport const removeTriggerListeners = (tooltip: DcUiTooltip): void => {\r\n  tooltip.el.removeEventListener('click', tooltip.onTooltipClick);\r\n\r\n  if (tooltip.trigger === 'hover') {\r\n    tooltip.triggerEl.removeEventListener('focus', tooltip.onTriggerMouseOver);\r\n    tooltip.triggerEl.removeEventListener('mouseover', tooltip.onTriggerMouseOver);\r\n    tooltip.triggerEl.removeEventListener('blur', tooltip.onTriggerMouseOut);\r\n    tooltip.triggerEl.removeEventListener('mouseout', tooltip.onTriggerMouseOut);\r\n    tooltip.triggerEl.removeEventListener('touchstart', tooltip.onTriggerTouchStart);\r\n  } else {\r\n    tooltip.triggerEl.removeEventListener('click', tooltip.onTriggerClick);\r\n    tooltip.triggerEl.removeEventListener('keydown', tooltip.onTriggerKeyDown);\r\n  }\r\n};\r\n\r\n/**\r\n * Adds event listeners to the document if they don't already exist.\r\n *\r\n * Also adds the tooltip to the list of registered tooltips.\r\n *\r\n * @param tooltip\r\n */\r\nexport const addDocumentListeners = (tooltip: DcUiTooltip): void => {\r\n  if (registeredTooltips.length === 0) {\r\n    document.addEventListener('scroll', onScrollOrResize);\r\n    window.addEventListener('resize', onScrollOrResize);\r\n    document.addEventListener('click', onDocumentClick);\r\n    document.addEventListener('keydown', onDocumentKeydown);\r\n  }\r\n  if (!registeredTooltips.includes(tooltip)) {\r\n    registeredTooltips.push(tooltip);\r\n  }\r\n};\r\n\r\n/**\r\n * Removes event listeners from the document if they're no longer needed.\r\n *\r\n * Also removes the tooltip from the list of registered tooltips.\r\n *\r\n * @param tooltip\r\n */\r\nexport const removeDocumentListeners = (tooltip: DcUiTooltip): void => {\r\n  const index = registeredTooltips.indexOf(tooltip);\r\n  if (index > -1) {\r\n    registeredTooltips.splice(index, 1);\r\n  }\r\n  if (registeredTooltips.length === 0) {\r\n    document.removeEventListener('scroll', onScrollOrResize);\r\n    window.removeEventListener('resize', onScrollOrResize);\r\n    document.removeEventListener('click', onDocumentClick);\r\n    document.removeEventListener('keydown', onDocumentKeydown);\r\n  }\r\n};\r\n\r\n/**\r\n * Updates the positions of all registered tooltips.\r\n *\r\n * Called on document scroll or window resize.\r\n */\r\nexport const onScrollOrResize = (): void => {\r\n  for (const tooltip of registeredTooltips) {\r\n    updateTooltipPosition(tooltip);\r\n  }\r\n};\r\n\r\n/**\r\n * Updates the position of a tooltip.\r\n *\r\n * @param tooltip\r\n */\r\nexport const updateTooltipPosition = (tooltip: DcUiTooltip): void => {\r\n  let arrowOffset = 0;\r\n  let actualPlacement: TTooltipPlacement = tooltip.placement;\r\n  const originalPlacement: TTooltipPlacement = tooltip.placement;\r\n  let tooltipWidth: number = null;\r\n  tooltip.el.style.width = null;\r\n\r\n  let tooltipRect = tooltip.el.getBoundingClientRect();\r\n  const triggerRect = tooltip.triggerEl.getBoundingClientRect();\r\n\r\n  // calculate \"desired\" positions\r\n  let [targetXPos, targetYPos] = targetPosition(tooltipRect, triggerRect, actualPlacement);\r\n\r\n  // if the tooltip is out of bounds, adjust the placement\r\n  [targetXPos, targetYPos, actualPlacement] = checkAndAdjustPlacement(\r\n    targetXPos,\r\n    targetYPos,\r\n    actualPlacement,\r\n    originalPlacement,\r\n    tooltipRect,\r\n    triggerRect\r\n  );\r\n\r\n  // for top and bottom placements: if it's still out of bounds, adjust the position, arrow offset and width\r\n  if (['top', 'bottom'].includes(actualPlacement)) {\r\n    [targetXPos, targetYPos, arrowOffset, tooltipWidth] = handleOutOfBoundsHorizontally(\r\n      targetXPos,\r\n      targetYPos,\r\n      tooltipRect,\r\n      triggerRect\r\n    );\r\n\r\n    // apply the calculated width\r\n    tooltip.el.style.width = tooltipWidth === null ? null : `${tooltipWidth}px`;\r\n\r\n    // the width change may have changed the height too, so recalculate the target Y position\r\n    tooltipRect = tooltip.el.getBoundingClientRect();\r\n    targetYPos = targetPosition(tooltipRect, triggerRect, actualPlacement)[1];\r\n  }\r\n\r\n  // for left and right placements: if it's still out of bounds, adjust the position and arrow offset\r\n  if (['left', 'right'].includes(actualPlacement)) {\r\n    [targetYPos, arrowOffset] = handleOutOfBoundsVertically(targetYPos, tooltipRect, triggerRect);\r\n  }\r\n\r\n  // re-inject the CSS to update the placement and arrow position\r\n  injectCSS(\r\n    tooltip.el,\r\n    createStyles,\r\n    actualPlacement,\r\n    arrowOffset,\r\n    tooltip.maxWidth,\r\n    tooltip.isNestedTrigger\r\n  );\r\n\r\n  // apply the calculated position\r\n  tooltip.el.style.transform = `translate(${targetXPos}px, ${targetYPos}px)`;\r\n};\r\n\r\n/**\r\n * Changes the placement of a tooltip if it's outside the viewport bounds.\r\n *\r\n * If there is no placement that works, it falls back to either \"top\" or \"bottom\".\r\n *\r\n * @param targetXPos\r\n * @param targetYPos\r\n * @param placement\r\n * @param originalPlacement\r\n * @param tooltipRect\r\n * @param triggerRect\r\n */\r\nconst checkAndAdjustPlacement = (\r\n  targetXPos: number,\r\n  targetYPos: number,\r\n  placement: TTooltipPlacement,\r\n  originalPlacement: TTooltipPlacement,\r\n  tooltipRect: DOMRect,\r\n  triggerRect: DOMRect\r\n): [number, number, TTooltipPlacement] => {\r\n  // if the tooltip is out of bounds, try changing the placement (2 tries)\r\n  for (let i = 0; i <= 1; i++) {\r\n    // left/right only needs to change to top/bottom if it's out of bounds horizontally,\r\n    // top/bottom  only needs to change to left/right if it's out of bounds vertically\r\n    // other kinds of overflow are handled later\r\n    if (\r\n      (['left', 'right'].includes(placement) && outOfBoundsHorizontally(tooltipRect, targetXPos)) ||\r\n      (['top', 'bottom'].includes(placement) &&\r\n        outOfBoundsVerticallyIncludingScrolling(tooltipRect, targetYPos))\r\n    ) {\r\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n      // @ts-ignore\r\n      placement = {\r\n        left: 'top',\r\n        top: 'right',\r\n        right: 'bottom',\r\n        bottom: 'left',\r\n      }[placement];\r\n      [targetXPos, targetYPos] = targetPosition(tooltipRect, triggerRect, placement);\r\n    }\r\n  }\r\n\r\n  // if it's *still* out of bounds, at least make sure it's on the top or bottom\r\n  if (\r\n    outOfBoundsHorizontally(tooltipRect, targetXPos) ||\r\n    outOfBoundsVerticallyIncludingScrolling(tooltipRect, targetYPos)\r\n  ) {\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n    // @ts-ignore\r\n    placement = {\r\n      left: 'top',\r\n      top: 'top',\r\n      right: 'bottom',\r\n      bottom: 'bottom',\r\n    }[originalPlacement];\r\n    [targetXPos, targetYPos] = targetPosition(tooltipRect, triggerRect, placement);\r\n  }\r\n\r\n  // if it's *still* out of bounds vertically, then change top to bottom and vice versa\r\n  if (outOfBoundsVerticallyIncludingScrolling(tooltipRect, targetYPos)) {\r\n    placement = placement === 'top' ? 'bottom' : 'top';\r\n    [targetXPos, targetYPos] = targetPosition(tooltipRect, triggerRect, placement);\r\n  }\r\n\r\n  return [targetXPos, targetYPos, placement];\r\n};\r\n\r\n/**\r\n * Changes the position, width and arrow position of a tooltip if it's outside the viewport horizontally.\r\n *\r\n * This uses different logic than handleOutOfBoundsVertically,\r\n * because horizontal and vertical overflow are different use cases.\r\n *\r\n * @param targetXPos\r\n * @param targetYPos\r\n * @param tooltipRect\r\n * @param triggerRect\r\n */\r\nconst handleOutOfBoundsHorizontally = (\r\n  targetXPos: number,\r\n  targetYPos: number,\r\n  tooltipRect: DOMRect,\r\n  triggerRect: DOMRect\r\n): number[] => {\r\n  let tooltipWidth = null;\r\n\r\n  // if it's out of bounds on the left,\r\n  // move it right, then check if it's out of bounds on the right and cut off the excess width\r\n  if (targetXPos < VIEWPORT_MARGIN) {\r\n    targetXPos = VIEWPORT_MARGIN;\r\n    if (targetXPos + tooltipRect.width >= document.body.clientWidth - VIEWPORT_MARGIN) {\r\n      const diff = tooltipRect.width - (document.body.clientWidth - 2 * VIEWPORT_MARGIN);\r\n      tooltipWidth = tooltipRect.width - diff;\r\n    }\r\n  }\r\n\r\n  // if it's out of bounds on the right,\r\n  // move it left, then check if it's out of bounds on the left and cut off the excess width\r\n  if (targetXPos + tooltipRect.width >= document.body.clientWidth - VIEWPORT_MARGIN) {\r\n    targetXPos = document.body.clientWidth - tooltipRect.width - VIEWPORT_MARGIN;\r\n    if (targetXPos < VIEWPORT_MARGIN) {\r\n      const diff = tooltipRect.width - (document.body.clientWidth - 2 * VIEWPORT_MARGIN);\r\n      targetXPos = targetXPos + diff;\r\n      tooltipWidth = tooltipRect.width - diff;\r\n    }\r\n  }\r\n\r\n  // point the arrow to the center of the trigger\r\n  const width = tooltipWidth !== null ? tooltipWidth : tooltipRect.width;\r\n  const triggerCenter = triggerRect.x + triggerRect.width / 2;\r\n  const tooltipCenter = targetXPos + width / 2;\r\n  const targetOffset = triggerCenter - tooltipCenter;\r\n\r\n  // constrain the arrow to be within the tooltip\r\n  const limit = (width - ARROW_SIZE) / 2;\r\n  const arrowOffset = clamp(targetOffset, -limit, limit);\r\n\r\n  return [targetXPos, targetYPos, arrowOffset, tooltipWidth];\r\n};\r\n\r\n/**\r\n * Changes the position and arrow position of a tooltip if it's outside the viewport vertically.\r\n *\r\n * This uses different logic than handleOutOfBoundsHorizontally,\r\n * because horizontal and vertical overflow are different use cases.\r\n *\r\n * @param targetYPos\r\n * @param tooltipRect\r\n * @param triggerRect\r\n */\r\nconst handleOutOfBoundsVertically = (\r\n  targetYPos: number,\r\n  tooltipRect: DOMRect,\r\n  triggerRect: DOMRect\r\n): number[] => {\r\n  let arrowOffset = 0;\r\n\r\n  // case 1: trigger is off-screen (so far up that the tooltip has to move off-screen with it)\r\n  if (triggerRect.bottom < VIEWPORT_MARGIN) {\r\n    // make the tooltip move with the bottom of the trigger\r\n    targetYPos = triggerRect.bottom;\r\n    // put the arrow at the very top\r\n    arrowOffset = (ARROW_SIZE - tooltipRect.height) / 2;\r\n  }\r\n\r\n  // case 2: trigger is so far up that the tooltip can't be where it wants to (but can still be visible)\r\n  else if (targetYPos < VIEWPORT_MARGIN) {\r\n    // make the tooltip stick to the top of the viewport\r\n    targetYPos = VIEWPORT_MARGIN;\r\n    // point the arrow to the center of the trigger (but no further down than the center of the tooltip)\r\n    const tooltipCenter = targetYPos + tooltipRect.height / 2;\r\n    const triggerCenter = triggerRect.top + triggerRect.height / 2;\r\n    const targetArrowPos = Math.min(triggerCenter, tooltipCenter);\r\n    arrowOffset = targetArrowPos - tooltipCenter;\r\n  }\r\n\r\n  // case 3: trigger is off-screen (so far down that the tooltip has to move off-screen with it)\r\n  else if (triggerRect.top > window.innerHeight - VIEWPORT_MARGIN) {\r\n    // make the tooltip move with the top of the trigger\r\n    targetYPos = triggerRect.top - tooltipRect.height;\r\n    // put the arrow at the very bottom\r\n    arrowOffset = (tooltipRect.height - ARROW_SIZE) / 2;\r\n  }\r\n\r\n  // case 4: trigger is so far down that the tooltip can't be where it wants to (but can still be visible)\r\n  else if (targetYPos + tooltipRect.height > window.innerHeight - VIEWPORT_MARGIN) {\r\n    // make the tooltip stick to the bottom of the viewport\r\n    targetYPos = window.innerHeight - VIEWPORT_MARGIN - tooltipRect.height;\r\n    // point the arrow to the center of the trigger (but no further up than the center of the tooltip)\r\n    const tooltipCenter = targetYPos + tooltipRect.height / 2;\r\n    const triggerCenter = triggerRect.top + triggerRect.height / 2;\r\n    const targetArrowPos = Math.max(triggerCenter, tooltipCenter);\r\n    arrowOffset = targetArrowPos - tooltipCenter;\r\n  }\r\n\r\n  // constrain the arrow to be within the tooltip\r\n  const limit = (tooltipRect.height - ARROW_SIZE) / 2;\r\n  arrowOffset = clamp(arrowOffset, -limit, limit);\r\n\r\n  return [targetYPos, arrowOffset];\r\n};\r\n\r\n/**\r\n * Checks if a tooltip is outside the viewport horizontally (left or right).\r\n *\r\n * @param tooltipRect\r\n * @param targetXPos\r\n */\r\nconst outOfBoundsHorizontally = (tooltipRect: DOMRect, targetXPos: number): boolean => {\r\n  return (\r\n    targetXPos < VIEWPORT_MARGIN ||\r\n    targetXPos + tooltipRect.width > document.body.clientWidth - VIEWPORT_MARGIN\r\n  );\r\n};\r\n\r\n/**\r\n * Checks if a tooltip is outside the viewport vertically (top or bottom), taking scrolling into account.\r\n *\r\n * If the tooltip is outside the viewport, but there's room to scroll it back into view,\r\n * it doesn't count as \"outside the viewport\".\r\n *\r\n * @param tooltipRect\r\n * @param targetYPos\r\n */\r\nconst outOfBoundsVerticallyIncludingScrolling = (\r\n  tooltipRect: DOMRect,\r\n  targetYPos: number\r\n): boolean => {\r\n  const scrollDistFromTop = window.scrollY;\r\n  const scrollDistFromBottom = document.body.scrollHeight - window.innerHeight - window.scrollY;\r\n  return (\r\n    targetYPos < VIEWPORT_MARGIN - scrollDistFromTop ||\r\n    targetYPos + tooltipRect.height > window.innerHeight + scrollDistFromBottom - VIEWPORT_MARGIN\r\n  );\r\n};\r\n\r\n/**\r\n *\r\n * Calculates the tooltip position given the trigger element and the tooltip placement.\r\n *\r\n * Note that this is just the \"desired\" position.\r\n * It can (and will) be changed by the calling function if it makes the tooltip go out of bounds.\r\n *\r\n * @param tooltipRect\r\n * @param triggerRect\r\n * @param placement\r\n */\r\nconst targetPosition = (\r\n  tooltipRect: DOMRect,\r\n  triggerRect: DOMRect,\r\n  placement: TTooltipPlacement\r\n): number[] => {\r\n  const targetXPos = {\r\n    top: triggerRect.left + triggerRect.width / 2 - tooltipRect.width / 2,\r\n    right: triggerRect.right + TOOLTIP_MARGIN,\r\n    bottom: triggerRect.left + triggerRect.width / 2 - tooltipRect.width / 2,\r\n    left: triggerRect.left - tooltipRect.width - TOOLTIP_MARGIN,\r\n  }[placement];\r\n\r\n  const targetYPos = {\r\n    top: triggerRect.top - tooltipRect.height - TOOLTIP_MARGIN,\r\n    right: triggerRect.top + triggerRect.height / 2 - tooltipRect.height / 2,\r\n    bottom: triggerRect.bottom + TOOLTIP_MARGIN,\r\n    left: triggerRect.top + triggerRect.height / 2 - tooltipRect.height / 2,\r\n  }[placement];\r\n\r\n  return [targetXPos, targetYPos];\r\n};\r\n\r\nfunction clamp(val, min, max) {\r\n  return val > max ? max : val < min ? min : val;\r\n}\r\n","import { color as colorUtils, getCss } from '../../utils';\r\nimport { TTooltipPlacement, ARROW_SIZE, TRANSITION_TIME } from './tooltip-utils';\r\n\r\nconst arrowBorder = `${ARROW_SIZE / 2}px solid ${colorUtils.grey03}`;\r\nconst arrowBackground = `${ARROW_SIZE / 2}px solid ${colorUtils.white}`;\r\n\r\nfunction arrowStyles(placement: TTooltipPlacement, arrowOffset) {\r\n  return {\r\n    top: {\r\n      bottom: '0',\r\n      left: '50%',\r\n      transform: `translateX(-50%) translateX(${arrowOffset}px)`,\r\n    },\r\n    right: {\r\n      left: '0',\r\n      top: '50%',\r\n      transform: `translateY(-50%) translateY(${arrowOffset}px)`,\r\n    },\r\n    bottom: {\r\n      top: '0',\r\n      left: '50%',\r\n      transform: `translateX(-50%) translateX(${arrowOffset}px)`,\r\n    },\r\n    left: {\r\n      right: '0',\r\n      top: '50%',\r\n      transform: `translateY(-50%) translateY(${arrowOffset}px)`,\r\n    },\r\n  }[placement];\r\n}\r\n\r\nfunction arrowBeforeStyles(placement: TTooltipPlacement) {\r\n  return {\r\n    top: {\r\n      bottom: `-${ARROW_SIZE + 1}px`,\r\n      borderTop: arrowBorder,\r\n    },\r\n    right: {\r\n      left: `-${ARROW_SIZE + 1}px`,\r\n      borderRight: arrowBorder,\r\n    },\r\n    bottom: {\r\n      top: `-${ARROW_SIZE + 1}px`,\r\n      borderBottom: arrowBorder,\r\n    },\r\n    left: {\r\n      right: `-${ARROW_SIZE + 1}px`,\r\n      borderLeft: arrowBorder,\r\n    },\r\n  }[placement];\r\n}\r\n\r\nfunction arrowAfterStyles(placement: TTooltipPlacement) {\r\n  return {\r\n    top: {\r\n      bottom: `-${ARROW_SIZE}px`,\r\n      borderTop: arrowBackground,\r\n    },\r\n    right: {\r\n      left: `-${ARROW_SIZE}px`,\r\n      borderRight: arrowBackground,\r\n    },\r\n    bottom: {\r\n      top: `-${ARROW_SIZE}px`,\r\n      borderBottom: arrowBackground,\r\n    },\r\n    left: {\r\n      right: `-${ARROW_SIZE}px`,\r\n      borderLeft: arrowBackground,\r\n    },\r\n  }[placement];\r\n}\r\n\r\nexport const createStyles = (\r\n  placement: TTooltipPlacement,\r\n  arrowOffset: number,\r\n  maxWidth: number,\r\n  nested: boolean\r\n): string => {\r\n  const styles = getCss({\r\n    '@global': {\r\n      ':host': {\r\n        display: 'block',\r\n        width: 'fit-content',\r\n        maxWidth: `${maxWidth}px`,\r\n        position: 'fixed',\r\n        top: '0',\r\n        left: '0',\r\n        zIndex: nested ? '10000' : '9999',\r\n        pointerEvents: 'none',\r\n      },\r\n\r\n      '.dc-ui-tooltip__container': {\r\n        position: 'relative',\r\n        border: `1px solid ${colorUtils.grey02}`,\r\n        backgroundColor: colorUtils.white,\r\n        // using drop-shadow instead of box-shadow adds shadow to the arrow as well\r\n        // note: for drop-shadow, the blur radius needs to be halved (6px --> 3px) to give the same result as box-shadow\r\n        filter: 'drop-shadow(0 2px 3px rgba(0, 0, 0, 0.3))',\r\n        padding: '1rem',\r\n        opacity: 0,\r\n        pointerEvents: 'none',\r\n\r\n        '&--opening, &--closing': {\r\n          transition: `opacity ${TRANSITION_TIME}ms`,\r\n        },\r\n\r\n        '&--opening, &--open': {\r\n          opacity: 1,\r\n          pointerEvents: 'initial',\r\n        },\r\n\r\n        '&--closing': {\r\n          opacity: 0,\r\n        },\r\n      },\r\n\r\n      '.dc-ui-tooltip__arrow': {\r\n        position: 'absolute',\r\n        width: `${ARROW_SIZE}px`,\r\n        height: `${ARROW_SIZE}px`,\r\n        ...arrowStyles(placement, arrowOffset),\r\n\r\n        '&::before, &::after': {\r\n          content: '\"\"',\r\n          position: 'absolute',\r\n          width: '0',\r\n          height: '0',\r\n          border: `${ARROW_SIZE / 2}px solid transparent`,\r\n        },\r\n\r\n        '&::before': {\r\n          ...arrowBeforeStyles(placement),\r\n        },\r\n\r\n        '&::after': {\r\n          ...arrowAfterStyles(placement),\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  return styles;\r\n};\r\n","import { Component, Host, h, Element, Prop, State, Method } from '@stencil/core';\r\nimport { createUuid, injectCSS } from '../../utils';\r\nimport { createStyles } from './tooltip-styles';\r\nimport {\r\n  TTooltipPlacement,\r\n  TTooltipTrigger,\r\n  removeDocumentListeners,\r\n  updateTooltipPosition,\r\n  toggleTooltip,\r\n  openTooltip,\r\n  closeTooltip,\r\n  addTriggerListeners,\r\n  removeTriggerListeners,\r\n} from './tooltip-utils';\r\n\r\n@Component({\r\n  tag: 'dc-ui-tooltip',\r\n  shadow: true,\r\n})\r\nexport class DcUiTooltip {\r\n  @Element() el: HTMLElement;\r\n  @Prop() placement: TTooltipPlacement = 'top';\r\n  @Prop() content: string = null;\r\n  @Prop() trigger: TTooltipTrigger = 'hover';\r\n  @Prop() triggerElement = '';\r\n  @Prop() maxWidth = 500;\r\n  @Prop() hoverDelay = 0;\r\n\r\n  @State() open = false;\r\n  @State() opening = false;\r\n  @State() closing = false;\r\n\r\n  triggerEl: HTMLElement;\r\n  containerEl: HTMLElement;\r\n  slotEl: Element;\r\n  contentEl: Element;\r\n  uuid: string;\r\n  timeoutID: ReturnType<typeof setTimeout>;\r\n  isNestedTooltip: boolean;\r\n  isNestedTrigger: boolean;\r\n  hasNestedTooltip: boolean;\r\n\r\n  @Method() show(): Promise<boolean> {\r\n    return new Promise((resolve) => {\r\n      openTooltip(this);\r\n      resolve(true);\r\n    });\r\n  }\r\n\r\n  @Method() hide(): Promise<boolean> {\r\n    return new Promise((resolve) => {\r\n      closeTooltip(this);\r\n      resolve(true);\r\n    });\r\n  }\r\n\r\n  connectedCallback() {\r\n    // get reference of the root element\r\n    const shadowRoot = this.el.getRootNode() as ShadowRoot;\r\n\r\n    // search for trigger element. Either in light DOM or in shadow DOM\r\n    this.triggerEl = shadowRoot.getElementById(this.triggerElement);\r\n  }\r\n\r\n  componentWillLoad() {\r\n    if (!this.triggerEl) {\r\n      console.warn('tooltip has no trigger element');\r\n      return;\r\n    }\r\n\r\n    this.uuid = createUuid();\r\n    this.triggerEl.setAttribute('tabindex', '0');\r\n    this.triggerEl.setAttribute('role', 'button');\r\n    this.triggerEl.setAttribute('aria-expanded', 'false');\r\n    this.triggerEl.setAttribute('aria-describedby', this.uuid);\r\n\r\n    // check if trigger element is inside another tooltip\r\n    this.isNestedTrigger = this.triggerEl.closest('dc-ui-tooltip') ? true : false;\r\n\r\n    // check if tooltip is inside another tooltip\r\n    const parent = this.el.closest('dc-ui-tooltip');\r\n    this.isNestedTooltip = !!parent?.contains(this.el);\r\n\r\n    // move tooltip to the end of the body if it's inside another tooltip\r\n    if (this.isNestedTooltip) {\r\n      const approot = document.querySelector('dc-ui-tooltip') || document.body;\r\n      approot.parentElement.appendChild(this.el);\r\n    }\r\n\r\n    // if trigger element is inside another tooltip, use timeout to initialize at the end of the queue\r\n    if (this.isNestedTrigger) {\r\n      this.timeoutID = setTimeout(() => {\r\n        addTriggerListeners(this);\r\n      }, 0);\r\n    } else {\r\n      addTriggerListeners(this);\r\n    }\r\n  }\r\n\r\n  componentDidRender() {\r\n    if (!this.triggerEl) {\r\n      return;\r\n    }\r\n\r\n    updateTooltipPosition(this);\r\n\r\n    if (this.content !== null) {\r\n      this.slotEl.remove();\r\n    } else {\r\n      this.contentEl.remove();\r\n    }\r\n\r\n    // check if inside slot is another tooltip\r\n    this.hasNestedTooltip = this.el.querySelector('dc-ui-tooltip') ? true : false;\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    if (!this.triggerEl) {\r\n      return;\r\n    }\r\n    removeDocumentListeners(this);\r\n    removeTriggerListeners(this);\r\n  }\r\n\r\n  onTriggerClick = (e: MouseEvent): void => {\r\n    e.stopPropagation();\r\n    if (this.trigger === 'click') {\r\n      toggleTooltip(this, e);\r\n    }\r\n  };\r\n\r\n  onTooltipClick = (e: MouseEvent): void => {\r\n    const target = e.target as HTMLElement;\r\n    if (target === e.currentTarget) {\r\n      e.stopPropagation();\r\n    }\r\n  };\r\n\r\n  onTriggerMouseOver = (): void => {\r\n    // add delay to prevent instant tooltip opening\r\n    setTimeout(() => {\r\n      openTooltip(this);\r\n    }, this.hoverDelay);\r\n  };\r\n\r\n  onTriggerMouseOut = (e: MouseEvent): void => {\r\n    // add delay to prevent tooltip from closing when moving from trigger to tooltip\r\n    setTimeout(() => {\r\n      closeTooltip(this, e);\r\n    }, this.hoverDelay);\r\n  };\r\n\r\n  onTriggerTouchStart = (e: MouseEvent): void => {\r\n    toggleTooltip(this, e);\r\n  };\r\n\r\n  onTriggerKeyDown = (e: KeyboardEvent): void => {\r\n    const { key } = e;\r\n    if (['SpaceBar', 'Enter', ' '].includes(key)) {\r\n      toggleTooltip(this, e);\r\n    }\r\n  };\r\n\r\n  render() {\r\n    if (!this.triggerEl) {\r\n      return;\r\n    }\r\n    const arrowOffset = 0;\r\n    injectCSS(\r\n      this.el,\r\n      createStyles,\r\n      this.placement,\r\n      arrowOffset,\r\n      this.maxWidth,\r\n      this.isNestedTrigger\r\n    );\r\n\r\n    return (\r\n      <Host>\r\n        <div\r\n          ref={(el) => (this.containerEl = el)}\r\n          id={this.uuid}\r\n          class={{\r\n            'dc-ui-tooltip__container': true,\r\n            'dc-ui-tooltip__container--open': this.open,\r\n            'dc-ui-tooltip__container--opening': this.opening,\r\n            'dc-ui-tooltip__container--closing': this.closing,\r\n          }}\r\n          role=\"tooltip\"\r\n          aria-hidden=\"true\"\r\n          hidden>\r\n          <div ref={(el) => (this.slotEl = el)}>\r\n            <slot></slot>\r\n          </div>\r\n          <dc-ui-text\r\n            ref={(el) => (this.contentEl = el)}\r\n            variant=\"mid-size-text\">\r\n            {this.content}\r\n          </dc-ui-text>\r\n          <div class=\"dc-ui-tooltip__arrow\"></div>\r\n        </div>\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}