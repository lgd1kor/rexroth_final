{"ast":null,"code":"// // cytrobox.js\n\n// export const getCytroboxValues = (result) => {\n//   return {\n//     PATH: result.index.path,\n//     LINEID: result.index.lineid,\n//     NB: result.index.NB,\n//     TYPE: result.index.line.values.TYPE.current,\n//     V: result.index.line.values.V.current,\n//     CF: result.index.line.values.CF.current,\n//     CC: result.index.line.values.CC.current,\n//     C: result.index.line.values.C.current,\n//     MPG1: result.index.line.values.MPG1.current,\n//     CD1: result.index.line.values.CD1.current,\n//     MPG2: result.index.line.values.MPG2.current,\n//     CD2: result.index.line.values.CD2.current,\n//     OC: result.index.line.values.OC.current,\n//     OT: result.index.line.values.OT.current,\n//     ST: result.index.line.values.ST.current\n//   };\n// };\n\n// export const getCytroboxMiDent = (selectedValues) => {\n//   return `{${selectedValues.PATH}},013 {LINEID=${selectedValues.LINEID}} {NB=${selectedValues.NB}},\n//           {TYPE=${selectedValues.TYPE}},{V=${selectedValues.V}},{CF=${selectedValues.CF}},{CC=${selectedValues.CC}},\n//           {C=${selectedValues.C}},{MPG1=${selectedValues.MPG1}},{CD1=${selectedValues.CD1}},{MPG2=${selectedValues.MPG2}},\n//           {CD2=${selectedValues.CD2}},{OC=${selectedValues.OC}},{OT=${selectedValues.OT}},{ST=${selectedValues.ST}},`;\n// };\n\n// export const computeCytroboxTypecodeInfo = (selectedValues) => {\n//   return `${selectedValues.TYPE.split(':')[0]}-${selectedValues.V}/${selectedValues.CF.split(':')[0]}${selectedValues.CC.split(':')[0]}${selectedValues.C.split(':')[0]}/${selectedValues.MPG1}${selectedValues.CD1}/${selectedValues.MPG2.split(':')[0]}${selectedValues.CD2.split(':')[0]}/${selectedValues.OC}${selectedValues.OT}/${selectedValues.ST}`;\n// };\n\n// export const generateCytroboxTabledata = (indexPath, renderRow) => {\n//   return (\n//     <tbody>\n//       {renderRow(indexPath.MN.desc, indexPath.MN.values, 'MN', indexPath.MN.Unit)}\n//       {renderRow(indexPath.TYPE.desc, indexPath.TYPE.values, 'TYPE', indexPath.TYPE.Unit)}\n//       {renderRow(indexPath.V.desc, indexPath.V.values, 'V', indexPath.V.Unit)}\n//       {renderRow(indexPath.CF.desc, indexPath.CF.values, 'CF', indexPath.CF.Unit)}\n//       {renderRow(indexPath.CC.desc, indexPath.CC.values, 'CC', indexPath.CC.Unit)}\n//       {renderRow(indexPath.C.desc, indexPath.C.values, 'C', indexPath.C.Unit)}\n//       {renderRow(indexPath.MPG1.desc, indexPath.MPG1.values, 'MPG1', indexPath.MPG1.Unit)}\n//       {renderRow(indexPath.CD1.desc, indexPath.CD1.values, 'CD1', indexPath.CD1.Unit)}\n//       {renderRow(indexPath.MPG2.desc, indexPath.MPG2.values, 'MPG2', indexPath.MPG2.Unit)}\n//       {renderRow(indexPath.CD2.desc, indexPath.CD2.values, 'CD2', indexPath.CD2.Unit)}\n//       {renderRow(indexPath.OC.desc, indexPath.OC.values, 'OC', indexPath.OC.Unit)}\n//       {renderRow(indexPath.OT.desc, indexPath.OT.values, 'OT', indexPath.OT.Unit)}\n//       {renderRow(indexPath.ST.desc, indexPath.ST.values, 'ST', indexPath.ST.Unit)}\n//     </tbody>\n//   );\n// };\n\n// export const generateAllPossibleTypecodesCytrobox = (indexPath) => {\n//   const combinations = [];\n\n//   // Helper function to generate combinations\n//   const generateCombinations = (acc, fields) => {\n//     if (fields.length === 0) {\n//       // Join the components with separators\n//       const formattedCode = `${acc.TYPE}-${acc.V}/${acc.CF}${acc.CC}${acc.C}/${acc.MPG1}${acc.CD1}/${acc.MPG2}${acc.CD2}/${acc.OC}${acc.OT}/${acc.ST}`;\n//       combinations.push(formattedCode);\n//       return;\n//     }\n\n//     const [field, ...restFields] = fields;\n//     field.values.forEach(value => {\n//       generateCombinations({\n//         ...acc,\n//         [field.key]: value.value.split(':')[0] // Extract short code before colon\n//       }, restFields);\n//     });\n//   };\n\n//   // Extracting relevant fields and initializing the fields array\n//   const fields = [\n//     { key: 'TYPE', values: indexPath.TYPE.values },\n//     { key: 'V', values: indexPath.V.values },\n//     { key: 'CF', values: indexPath.CF.values },\n//     { key: 'CC', values: indexPath.CC.values },\n//     { key: 'C', values: indexPath.C.values },\n//     { key: 'MPG1', values: indexPath.MPG1.values },\n//     { key: 'CD1', values: indexPath.CD1.values },\n//     { key: 'MPG2', values: indexPath.MPG2.values },\n//     { key: 'CD2', values: indexPath.CD2.values },\n//     { key: 'OC', values: indexPath.OC.values },\n//     { key: 'OT', values: indexPath.OT.values },\n//     { key: 'ST', values: indexPath.ST.values }\n//   ];\n\n//   // Start generating combinations\n//   generateCombinations({}, fields);\n\n//   return combinations;\n// };\n\nexport const generateAllPossibleTypecodesCytrobox = indexPath => {\n  // Log the indexPath to ensure it is not undefined and contains the expected structure\n  console.log('indexPath:', indexPath);\n  if (!indexPath || !indexPath.TYPE) {\n    console.error('indexPath or indexPath.TYPE is undefined');\n    return [];\n  }\n  const combinations = [];\n\n  // Helper function to generate combinations\n  const generateCombinations = (acc, fields) => {\n    if (fields.length === 0) {\n      // Join the components with separators\n      const formattedCode = `${acc.TYPE}-${acc.V}/${acc.CF}${acc.CC}${acc.C}/${acc.MPG1}${acc.CD1}/${acc.MPG2}${acc.CD2}/${acc.OC}${acc.OT}/${acc.ST}`;\n      combinations.push(formattedCode);\n      return;\n    }\n    const [field, ...restFields] = fields;\n    field.values.forEach(value => {\n      generateCombinations({\n        ...acc,\n        [field.key]: value.value.split(':')[0] // Extract short code before colon\n      }, restFields);\n    });\n  };\n\n  // Extracting relevant fields and initializing the fields array\n  const fields = [{\n    key: 'TYPE',\n    values: indexPath.TYPE.values\n  }, {\n    key: 'V',\n    values: indexPath.V.values\n  }, {\n    key: 'CF',\n    values: indexPath.CF.values\n  }, {\n    key: 'CC',\n    values: indexPath.CC.values\n  }, {\n    key: 'C',\n    values: indexPath.C.values\n  }, {\n    key: 'MPG1',\n    values: indexPath.MPG1.values\n  }, {\n    key: 'CD1',\n    values: indexPath.CD1.values\n  }, {\n    key: 'MPG2',\n    values: indexPath.MPG2.values\n  }, {\n    key: 'CD2',\n    values: indexPath.CD2.values\n  }, {\n    key: 'OC',\n    values: indexPath.OC.values\n  }, {\n    key: 'OT',\n    values: indexPath.OT.values\n  }, {\n    key: 'ST',\n    values: indexPath.ST.values\n  }];\n\n  // Start generating combinations\n  generateCombinations({}, fields);\n  return combinations;\n};","map":{"version":3,"names":["generateAllPossibleTypecodesCytrobox","indexPath","console","log","TYPE","error","combinations","generateCombinations","acc","fields","length","formattedCode","V","CF","CC","C","MPG1","CD1","MPG2","CD2","OC","OT","ST","push","field","restFields","values","forEach","value","key","split"],"sources":["C:/Users/LGD1KOR/Desktop/react/my-app/src/Products/cytrobox.js"],"sourcesContent":["// // cytrobox.js\r\n\r\n// export const getCytroboxValues = (result) => {\r\n//   return {\r\n//     PATH: result.index.path,\r\n//     LINEID: result.index.lineid,\r\n//     NB: result.index.NB,\r\n//     TYPE: result.index.line.values.TYPE.current,\r\n//     V: result.index.line.values.V.current,\r\n//     CF: result.index.line.values.CF.current,\r\n//     CC: result.index.line.values.CC.current,\r\n//     C: result.index.line.values.C.current,\r\n//     MPG1: result.index.line.values.MPG1.current,\r\n//     CD1: result.index.line.values.CD1.current,\r\n//     MPG2: result.index.line.values.MPG2.current,\r\n//     CD2: result.index.line.values.CD2.current,\r\n//     OC: result.index.line.values.OC.current,\r\n//     OT: result.index.line.values.OT.current,\r\n//     ST: result.index.line.values.ST.current\r\n//   };\r\n// };\r\n\r\n// export const getCytroboxMiDent = (selectedValues) => {\r\n//   return `{${selectedValues.PATH}},013 {LINEID=${selectedValues.LINEID}} {NB=${selectedValues.NB}},\r\n//           {TYPE=${selectedValues.TYPE}},{V=${selectedValues.V}},{CF=${selectedValues.CF}},{CC=${selectedValues.CC}},\r\n//           {C=${selectedValues.C}},{MPG1=${selectedValues.MPG1}},{CD1=${selectedValues.CD1}},{MPG2=${selectedValues.MPG2}},\r\n//           {CD2=${selectedValues.CD2}},{OC=${selectedValues.OC}},{OT=${selectedValues.OT}},{ST=${selectedValues.ST}},`;\r\n// };\r\n\r\n// export const computeCytroboxTypecodeInfo = (selectedValues) => {\r\n//   return `${selectedValues.TYPE.split(':')[0]}-${selectedValues.V}/${selectedValues.CF.split(':')[0]}${selectedValues.CC.split(':')[0]}${selectedValues.C.split(':')[0]}/${selectedValues.MPG1}${selectedValues.CD1}/${selectedValues.MPG2.split(':')[0]}${selectedValues.CD2.split(':')[0]}/${selectedValues.OC}${selectedValues.OT}/${selectedValues.ST}`;\r\n// };\r\n\r\n// export const generateCytroboxTabledata = (indexPath, renderRow) => {\r\n//   return (\r\n//     <tbody>\r\n//       {renderRow(indexPath.MN.desc, indexPath.MN.values, 'MN', indexPath.MN.Unit)}\r\n//       {renderRow(indexPath.TYPE.desc, indexPath.TYPE.values, 'TYPE', indexPath.TYPE.Unit)}\r\n//       {renderRow(indexPath.V.desc, indexPath.V.values, 'V', indexPath.V.Unit)}\r\n//       {renderRow(indexPath.CF.desc, indexPath.CF.values, 'CF', indexPath.CF.Unit)}\r\n//       {renderRow(indexPath.CC.desc, indexPath.CC.values, 'CC', indexPath.CC.Unit)}\r\n//       {renderRow(indexPath.C.desc, indexPath.C.values, 'C', indexPath.C.Unit)}\r\n//       {renderRow(indexPath.MPG1.desc, indexPath.MPG1.values, 'MPG1', indexPath.MPG1.Unit)}\r\n//       {renderRow(indexPath.CD1.desc, indexPath.CD1.values, 'CD1', indexPath.CD1.Unit)}\r\n//       {renderRow(indexPath.MPG2.desc, indexPath.MPG2.values, 'MPG2', indexPath.MPG2.Unit)}\r\n//       {renderRow(indexPath.CD2.desc, indexPath.CD2.values, 'CD2', indexPath.CD2.Unit)}\r\n//       {renderRow(indexPath.OC.desc, indexPath.OC.values, 'OC', indexPath.OC.Unit)}\r\n//       {renderRow(indexPath.OT.desc, indexPath.OT.values, 'OT', indexPath.OT.Unit)}\r\n//       {renderRow(indexPath.ST.desc, indexPath.ST.values, 'ST', indexPath.ST.Unit)}\r\n//     </tbody>\r\n//   );\r\n// };\r\n\r\n// export const generateAllPossibleTypecodesCytrobox = (indexPath) => {\r\n//   const combinations = [];\r\n\r\n//   // Helper function to generate combinations\r\n//   const generateCombinations = (acc, fields) => {\r\n//     if (fields.length === 0) {\r\n//       // Join the components with separators\r\n//       const formattedCode = `${acc.TYPE}-${acc.V}/${acc.CF}${acc.CC}${acc.C}/${acc.MPG1}${acc.CD1}/${acc.MPG2}${acc.CD2}/${acc.OC}${acc.OT}/${acc.ST}`;\r\n//       combinations.push(formattedCode);\r\n//       return;\r\n//     }\r\n\r\n//     const [field, ...restFields] = fields;\r\n//     field.values.forEach(value => {\r\n//       generateCombinations({\r\n//         ...acc,\r\n//         [field.key]: value.value.split(':')[0] // Extract short code before colon\r\n//       }, restFields);\r\n//     });\r\n//   };\r\n\r\n//   // Extracting relevant fields and initializing the fields array\r\n//   const fields = [\r\n//     { key: 'TYPE', values: indexPath.TYPE.values },\r\n//     { key: 'V', values: indexPath.V.values },\r\n//     { key: 'CF', values: indexPath.CF.values },\r\n//     { key: 'CC', values: indexPath.CC.values },\r\n//     { key: 'C', values: indexPath.C.values },\r\n//     { key: 'MPG1', values: indexPath.MPG1.values },\r\n//     { key: 'CD1', values: indexPath.CD1.values },\r\n//     { key: 'MPG2', values: indexPath.MPG2.values },\r\n//     { key: 'CD2', values: indexPath.CD2.values },\r\n//     { key: 'OC', values: indexPath.OC.values },\r\n//     { key: 'OT', values: indexPath.OT.values },\r\n//     { key: 'ST', values: indexPath.ST.values }\r\n//   ];\r\n\r\n//   // Start generating combinations\r\n//   generateCombinations({}, fields);\r\n\r\n//   return combinations;\r\n// };\r\n\r\nexport const generateAllPossibleTypecodesCytrobox = (indexPath) => {\r\n  // Log the indexPath to ensure it is not undefined and contains the expected structure\r\n  console.log('indexPath:', indexPath);\r\n\r\n  if (!indexPath || !indexPath.TYPE) {\r\n    console.error('indexPath or indexPath.TYPE is undefined');\r\n    return [];\r\n  }\r\n\r\n  const combinations = [];\r\n\r\n  // Helper function to generate combinations\r\n  const generateCombinations = (acc, fields) => {\r\n    if (fields.length === 0) {\r\n      // Join the components with separators\r\n      const formattedCode = `${acc.TYPE}-${acc.V}/${acc.CF}${acc.CC}${acc.C}/${acc.MPG1}${acc.CD1}/${acc.MPG2}${acc.CD2}/${acc.OC}${acc.OT}/${acc.ST}`;\r\n      combinations.push(formattedCode);\r\n      return;\r\n    }\r\n\r\n    const [field, ...restFields] = fields;\r\n    field.values.forEach(value => {\r\n      generateCombinations({\r\n        ...acc,\r\n        [field.key]: value.value.split(':')[0] // Extract short code before colon\r\n      }, restFields);\r\n    });\r\n  };\r\n\r\n  // Extracting relevant fields and initializing the fields array\r\n  const fields = [\r\n    { key: 'TYPE', values: indexPath.TYPE.values },\r\n    { key: 'V', values: indexPath.V.values },\r\n    { key: 'CF', values: indexPath.CF.values },\r\n    { key: 'CC', values: indexPath.CC.values },\r\n    { key: 'C', values: indexPath.C.values },\r\n    { key: 'MPG1', values: indexPath.MPG1.values },\r\n    { key: 'CD1', values: indexPath.CD1.values },\r\n    { key: 'MPG2', values: indexPath.MPG2.values },\r\n    { key: 'CD2', values: indexPath.CD2.values },\r\n    { key: 'OC', values: indexPath.OC.values },\r\n    { key: 'OT', values: indexPath.OT.values },\r\n    { key: 'ST', values: indexPath.ST.values }\r\n  ];\r\n\r\n  // Start generating combinations\r\n  generateCombinations({}, fields);\r\n\r\n  return combinations;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}