{"version":3,"file":"static/js/1217.890e5d89.chunk.js","mappings":"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","sources":["../node_modules/@boschrexroth/nextgen-web-ui-toolkit/dist/esm/src/components/dc-ui-anchor-bar/dc-ui-anchor-bar.scss?tag=dc-ui-anchor-bar&encapsulation=shadow","../node_modules/@boschrexroth/nextgen-web-ui-toolkit/dist/esm/src/components/dc-ui-anchor-bar/dc-ui-anchor-bar.tsx"],"sourcesContent":[":host {\r\n  --anchor-bar-max-width: 1920px;\r\n\r\n  @include media-max('xxl', false) {\r\n    --anchor-bar-max-width: 1440px;\r\n  }\r\n}\r\n\r\n.dc-ui-anchor-bar {\r\n  background-color: $color-white;\r\n  position: relative;\r\n  transition: top 0.3s ease-in-out;\r\n  display: flex;\r\n\r\n  &:before {\r\n    content: '';\r\n    position: absolute;\r\n    bottom: 0;\r\n    left: 0;\r\n    right: 0;\r\n    width: 100%;\r\n    height: 1px;\r\n    background-color: $color-grey-03;\r\n    z-index: 1;\r\n  }\r\n\r\n  &--is-sticky {\r\n    position: fixed;\r\n    top: var(--header-offset-height, 0);\r\n    left: 0;\r\n    right: 0;\r\n    z-index: 1000;\r\n    max-width: var(--anchor-bar-max-width);\r\n    margin: 0 auto;\r\n    box-shadow: 0px 16px 32px -16px rgba(0, 43, 73, 0.32);\r\n\r\n    &:before {\r\n      bottom: unset;\r\n      top: 0;\r\n      background-color: $color-grey-01;\r\n    }\r\n  }\r\n\r\n  &__inner {\r\n    display: grid;\r\n    grid-template-columns: 1fr;\r\n    align-items: center;\r\n    margin: 0 auto;\r\n    max-width: 1170px;\r\n    height: 48px;\r\n    width: 100%;\r\n\r\n    &--has-overflow {\r\n      padding-inline: 15px;\r\n      grid-template-columns: auto 1fr auto;\r\n      gap: 12px;\r\n    }\r\n  }\r\n\r\n  &__inner-wrapper {\r\n    display: flex;\r\n    gap: 12px;\r\n    max-width: 100%;\r\n    margin: 0 auto;\r\n    overflow-x: auto;\r\n    // Hide scrollbar\r\n    &::-webkit-scrollbar {\r\n      display: none;\r\n    }\r\n  }\r\n}\r\n","import { Component, h, Element, State, Watch, Listen, Method, Prop } from '@stencil/core';\r\n\r\n@Component({\r\n  tag: 'dc-ui-anchor-bar',\r\n  styleUrl: 'dc-ui-anchor-bar.scss',\r\n  shadow: true,\r\n})\r\nexport class DcUiAnchorBar {\r\n  @Element() el: HTMLElement;\r\n  @Prop() scrollOffset: number = 0;\r\n  @State() isAnchorBarSticky: boolean = false;\r\n  @State() isHeaderShown: boolean = false;\r\n  @State() hasOverflow: boolean = false;\r\n  @State() isAtStart: boolean = true;\r\n  @State() isAtEnd: boolean = false;\r\n\r\n  // DOM Elements\r\n  private header: HTMLElement;\r\n  private anchorBarContainer: HTMLElement;\r\n  private anchorItems: HTMLElement[] = [];\r\n  private sections: HTMLElement[] = [];\r\n\r\n  // Observers\r\n  private sectionVisibilityObserver: IntersectionObserver;\r\n  private anchorBarStickyObserver: IntersectionObserver;\r\n  private lastSectionObserver: IntersectionObserver;\r\n\r\n  // State tracking\r\n  private currentIndex: number = -1;\r\n  private lastScrollPosition: number = window.scrollY;\r\n  private isScrollingUp: boolean = false;\r\n  private lastKnownScrollPosition: number = 0;\r\n  private isShadowRoot: boolean = false;\r\n\r\n  private sectionsMap: Map<string, HTMLElement> = new Map();\r\n\r\n  // Layout constants\r\n  private readonly LAYOUT = {\r\n    INLINE_PADDING: 15,\r\n    OVERFLOW_BUTTON_WIDTH: 32,\r\n    OVERFLOW_BUTTON_GAP: 12,\r\n    ITEM_GAP: 12,\r\n  } as const;\r\n\r\n  @Listen('dcHeaderShown', { target: 'window' })\r\n  handleHeaderShown() {\r\n    this.isHeaderShown = true;\r\n  }\r\n\r\n  @Listen('dcHeaderHidden', { target: 'window' })\r\n  handleHeaderHidden() {\r\n    this.isHeaderShown = false;\r\n  }\r\n\r\n  @Watch('currentIndex')\r\n  handleCurrentIndexChange() {\r\n    this.updateButtonStates();\r\n  }\r\n\r\n  // Methods\r\n  @Method()\r\n  async goToSectionIndex(index: number) {\r\n    this.currentIndex = index;\r\n    this.toggleActiveAnchor(index);\r\n  }\r\n\r\n  // Lifecycle Methods\r\n  componentDidLoad() {\r\n    const rootNode = this.el.getRootNode() as Document | ShadowRoot;\r\n    this.isShadowRoot = rootNode instanceof ShadowRoot;\r\n\r\n    this.initializeElements();\r\n    this.setupObservers();\r\n    this.setupEventListeners();\r\n    this.checkForOverflow();\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.cleanupObservers();\r\n    this.cleanupEventListeners();\r\n  }\r\n\r\n  private setupEventListeners() {\r\n    this.setupClickHandlers();\r\n    window.addEventListener('scroll', this.handleScroll);\r\n    window.addEventListener('scroll', this.setScrollDirection);\r\n    window.addEventListener('resize', this.checkForOverflow);\r\n  }\r\n\r\n  private cleanupEventListeners() {\r\n    window.removeEventListener('scroll', this.handleScroll);\r\n    window.removeEventListener('scroll', this.setScrollDirection);\r\n    window.removeEventListener('resize', this.checkForOverflow);\r\n\r\n    // Add cleanup for anchor item click listeners\r\n    this.anchorItems.forEach((item) => {\r\n      item.removeEventListener('click', this.handleAnchorClick);\r\n    });\r\n  }\r\n\r\n  private cleanupObservers() {\r\n    this.sectionVisibilityObserver?.disconnect();\r\n    this.anchorBarStickyObserver?.disconnect();\r\n    this.lastSectionObserver?.disconnect();\r\n  }\r\n\r\n  // Initialize Elements\r\n  private initializeElements() {\r\n    // Get header reference considering shadow DOM\r\n    this.header = document.querySelector('dc-ui-header') || null;\r\n\r\n    // Get anchor items\r\n    this.anchorItems = Array.from(this.el.children).filter(\r\n      (child) => child.tagName.toLowerCase() === 'dc-ui-anchor-bar-item'\r\n    ) as HTMLElement[];\r\n\r\n    if (this.isShadowRoot) {\r\n      this.sections = this.anchorItems.map((item) => {\r\n        const root = item.getRootNode() as ShadowRoot;\r\n        const section = root.host.shadowRoot.querySelector(item.getAttribute('href'));\r\n        this.sectionsMap.set(item.getAttribute('href'), section as HTMLElement);\r\n        return section as HTMLElement;\r\n      });\r\n    } else {\r\n      this.sections = this.anchorItems\r\n        .map((item) => {\r\n          const href = item.getAttribute('href');\r\n          const section = document.querySelector(href);\r\n          if (section) {\r\n            this.sectionsMap.set(href, section as HTMLElement);\r\n          }\r\n          return section;\r\n        })\r\n        .filter(Boolean) as HTMLElement[];\r\n    }\r\n\r\n    this.updateButtonStates();\r\n  }\r\n\r\n  private setupObservers() {\r\n    // Observer for sticky behavior\r\n    this.anchorBarStickyObserver = new IntersectionObserver(\r\n      ([entry]) => {\r\n        const shouldBeSticky = !entry.isIntersecting;\r\n        if (shouldBeSticky !== this.isAnchorBarSticky) {\r\n          this.isAnchorBarSticky = shouldBeSticky;\r\n          if (this.isAnchorBarSticky) {\r\n            this.updateStickyOffset();\r\n          }\r\n        }\r\n      },\r\n      {\r\n        threshold: 1,\r\n        rootMargin: '-1px 0px 0px 0px',\r\n      }\r\n    );\r\n\r\n    this.anchorBarStickyObserver.observe(this.el);\r\n\r\n    // Modified last section observer\r\n    const lastSection = this.sections[this.sections.length - 1]?.nextElementSibling;\r\n    if (lastSection) {\r\n      this.lastSectionObserver = new IntersectionObserver(\r\n        (entries) => {\r\n          const lastSectionEntry = entries[0];\r\n          const rect = lastSectionEntry.boundingClientRect;\r\n          const anchorBarHeight = this.getAnchorBarHeight();\r\n\r\n          if (!lastSectionEntry.isIntersecting && rect.bottom <= anchorBarHeight) {\r\n            // Past the bottom of all sections\r\n            this.isAnchorBarSticky = false;\r\n          } else if (lastSectionEntry.isIntersecting && this.isScrollingUp) {\r\n            // When scrolling back up into sections, let the anchorBarStickyObserver handle it\r\n            const anchorBarRect = this.el.getBoundingClientRect();\r\n            if (anchorBarRect.top <= 0) {\r\n              this.isAnchorBarSticky = true;\r\n              this.updateStickyOffset(true);\r\n            }\r\n          }\r\n        },\r\n        {\r\n          threshold: [0],\r\n          rootMargin: '0px 0px 0px 0px',\r\n        }\r\n      );\r\n      this.lastSectionObserver.observe(lastSection);\r\n    }\r\n  }\r\n\r\n  // Click Handlers\r\n  private setupClickHandlers() {\r\n    this.anchorItems.forEach((item) => {\r\n      item.addEventListener('click', this.handleAnchorClick);\r\n    });\r\n  }\r\n\r\n  // Move click handler to class method for proper cleanup\r\n  private handleAnchorClick = (e: Event) => {\r\n    e.preventDefault();\r\n    const item = e.currentTarget as HTMLElement;\r\n    const href = item.getAttribute('href');\r\n    this.scrollToSection(href);\r\n  };\r\n\r\n  // Helper Methods\r\n  private getHeaderHeight(): number {\r\n    if (!this.header) return 0;\r\n    return this.header.getBoundingClientRect().height;\r\n  }\r\n\r\n  private getAnchorBarHeight(): number {\r\n    return this.anchorBarContainer?.getBoundingClientRect().height ?? 0;\r\n  }\r\n\r\n  private updateStickyOffset(zero: boolean = false) {\r\n    this.el.style.setProperty('--header-offset-height', `${zero ? this.getHeaderHeight() : 0}px`);\r\n  }\r\n\r\n  private scrollToSection(href: string) {\r\n    const section = this.sectionsMap.get(href);\r\n    if (!section) return;\r\n\r\n    const scrollDirection = this.getScrollDirection(section as HTMLElement);\r\n\r\n    const headerHeight = scrollDirection === 'up' ? this.getHeaderHeight() : 0;\r\n    const anchorBarHeight = this.getAnchorBarHeight();\r\n    const safeZoneOffset = this.scrollOffset;\r\n    const totalOffset =\r\n      headerHeight +\r\n      anchorBarHeight +\r\n      (this.isAnchorBarSticky ? 0 : anchorBarHeight) +\r\n      safeZoneOffset;\r\n\r\n    // Set a CSS custom property for scroll-margin-top\r\n    (section as HTMLElement).style.scrollMarginTop = `${totalOffset}px`;\r\n\r\n    section.scrollIntoView({\r\n      behavior: 'smooth',\r\n      block: 'start',\r\n    });\r\n\r\n    // remove scroll-margin-top\r\n    (section as HTMLElement).style.removeProperty('scroll-margin-top');\r\n\r\n    // Update URL without scroll\r\n    history.pushState(null, '', href);\r\n  }\r\n\r\n  private setScrollDirection = (): void => {\r\n    const currentScrollPosition = window.scrollY;\r\n    const wasScrollingUp = this.isScrollingUp;\r\n    this.isScrollingUp = currentScrollPosition < this.lastScrollPosition;\r\n    this.lastScrollPosition = currentScrollPosition;\r\n\r\n    // Check if scroll direction changed and update offset if sticky\r\n    if (wasScrollingUp !== this.isScrollingUp && this.isAnchorBarSticky) {\r\n      this.updateStickyOffset(this.isScrollingUp);\r\n    }\r\n  };\r\n\r\n  private handleScroll = (): void => {\r\n    this.lastKnownScrollPosition = window.scrollY;\r\n\r\n    requestAnimationFrame(() => {\r\n      setTimeout(() => {\r\n        if (this.lastKnownScrollPosition === window.scrollY) {\r\n          this.updateActiveSection();\r\n        }\r\n      }, 150);\r\n    });\r\n  };\r\n\r\n  private updateActiveSection = (): void => {\r\n    // Skip updating active section if not sticky\r\n    if (!this.isAnchorBarSticky) {\r\n      this.currentIndex = -1;\r\n      this.toggleActiveAnchor(-1);\r\n      return;\r\n    }\r\n\r\n    const activeSection = this.getActiveSection();\r\n    this.currentIndex = activeSection;\r\n    this.toggleActiveAnchor(activeSection);\r\n  };\r\n\r\n  private getActiveSection = (): number => {\r\n    const headerOffset = this.isHeaderShown\r\n      ? this.getHeaderHeight() + this.getAnchorBarHeight()\r\n      : this.getAnchorBarHeight();\r\n    const currentPosition = window.scrollY + headerOffset;\r\n    let activeSection = null;\r\n\r\n    for (let i = this.sections.length - 1; i >= 0 && activeSection === null; i--) {\r\n      if (currentPosition >= this.getElementPosition(i)) {\r\n        activeSection = i;\r\n      }\r\n    }\r\n    return activeSection;\r\n  };\r\n\r\n  private getElementPosition = (index: number): number => {\r\n    const section = this.sections[index];\r\n    const headerOffset = this.isScrollingUp && this.isHeaderShown ? this.getHeaderHeight() : 0;\r\n    const anchorBarOffset = this.getAnchorBarHeight();\r\n    // Adjust the position calculation to account for header and anchor bar visibility\r\n    return section.getBoundingClientRect().top + window.scrollY - headerOffset - anchorBarOffset;\r\n  };\r\n\r\n  private toggleActiveAnchor = (index: number): void => {\r\n    const anchorElements = this.anchorItems;\r\n    for (let i = 0; i < anchorElements.length; i += 1) {\r\n      // Always remove attributes if not sticky or if not the active index\r\n      if (!this.isAnchorBarSticky || i !== index) {\r\n        anchorElements[i].removeAttribute('selected');\r\n        anchorElements[i].removeAttribute('aria-current');\r\n        continue;\r\n      }\r\n\r\n      // Only set attributes if sticky and is active index\r\n      anchorElements[i].setAttribute('selected', '');\r\n      anchorElements[i].setAttribute('aria-current', 'location');\r\n\r\n      if (i !== 0 && this.hasOverflow && this.isAnchorBarSticky) {\r\n        anchorElements[i].scrollIntoView({\r\n          behavior: 'smooth',\r\n          inline: 'center',\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  private getScrollDirection(targetSection: HTMLElement): 'up' | 'down' {\r\n    const currentSection = this.currentIndex !== -1 ? this.sections[this.currentIndex] : null;\r\n    if (!currentSection) {\r\n      return targetSection.getBoundingClientRect().top > window.innerHeight / 2 ? 'down' : 'up';\r\n    }\r\n    return targetSection.getBoundingClientRect().top < currentSection.getBoundingClientRect().top\r\n      ? 'up'\r\n      : 'down';\r\n  }\r\n\r\n  private checkForOverflow = () => {\r\n    if (!this.anchorBarContainer) return;\r\n\r\n    const { width: containerWidth } = this.anchorBarContainer.getBoundingClientRect();\r\n    const { INLINE_PADDING, OVERFLOW_BUTTON_WIDTH, OVERFLOW_BUTTON_GAP } = this.LAYOUT;\r\n\r\n    const availableWidth =\r\n      containerWidth - INLINE_PADDING * 2 - OVERFLOW_BUTTON_WIDTH * 2 - OVERFLOW_BUTTON_GAP * 2;\r\n\r\n    const itemsWidth = this.anchorItems.reduce(\r\n      (acc, item) => acc + item.getBoundingClientRect().width + this.LAYOUT.ITEM_GAP,\r\n      -this.LAYOUT.ITEM_GAP // Subtract one gap since we don't need it after the last item\r\n    );\r\n\r\n    this.hasOverflow = itemsWidth > availableWidth;\r\n  };\r\n\r\n  private handleOverflowButtonClick(direction: 'left' | 'right') {\r\n    const nextIndex =\r\n      direction === 'left'\r\n        ? Math.max(0, this.currentIndex - 1)\r\n        : Math.min(this.anchorItems.length - 1, this.currentIndex + 1);\r\n\r\n    if (nextIndex !== this.currentIndex) {\r\n      this.scrollToSection(this.anchorItems[nextIndex].getAttribute('href'));\r\n    }\r\n  }\r\n\r\n  private updateButtonStates() {\r\n    this.isAtStart = this.currentIndex <= 0;\r\n    this.isAtEnd = this.currentIndex >= this.anchorItems.length - 1;\r\n  }\r\n\r\n  // Render\r\n  render() {\r\n    const overflowButtonLeft = (\r\n      <dc-ui-button\r\n        icon=\"dc_backward_left\"\r\n        variant=\"link\"\r\n        size=\"small\"\r\n        hide-label=\"true\"\r\n        disabled={this.isAtStart}\r\n        onClick={() => this.handleOverflowButtonClick('left')}>\r\n        Go to previous section\r\n      </dc-ui-button>\r\n    );\r\n\r\n    const overflowButtonRight = (\r\n      <dc-ui-button\r\n        icon=\"dc_forward_right\"\r\n        variant=\"link\"\r\n        size=\"small\"\r\n        hide-label=\"true\"\r\n        disabled={this.isAtEnd}\r\n        onClick={() => this.handleOverflowButtonClick('right')}>\r\n        Go to next section\r\n      </dc-ui-button>\r\n    );\r\n\r\n    return (\r\n      <div\r\n        class={{\r\n          'dc-ui-anchor-bar': true,\r\n          'dc-ui-anchor-bar--is-sticky': this.isAnchorBarSticky,\r\n        }}>\r\n        <div\r\n          class={{\r\n            'dc-ui-anchor-bar__inner': true,\r\n            'dc-ui-anchor-bar__inner--has-overflow': this.hasOverflow,\r\n          }}\r\n          ref={(el) => (this.anchorBarContainer = el)}>\r\n          {this.hasOverflow && overflowButtonLeft}\r\n          <nav class=\"dc-ui-anchor-bar__inner-wrapper\">\r\n            <slot></slot>\r\n          </nav>\r\n          {this.hasOverflow && overflowButtonRight}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n"],"names":["DcUiAnchorBar","anchorItems","sections","currentIndex","lastScrollPosition","window","scrollY","isScrollingUp","lastKnownScrollPosition","isShadowRoot","sectionsMap","Map","LAYOUT","INLINE_PADDING","OVERFLOW_BUTTON_WIDTH","OVERFLOW_BUTTON_GAP","ITEM_GAP","handleAnchorClick","e","preventDefault","href","currentTarget","getAttribute","this","scrollToSection","setScrollDirection","currentScrollPosition","wasScrollingUp","isAnchorBarSticky","updateStickyOffset","handleScroll","requestAnimationFrame","setTimeout","updateActiveSection","toggleActiveAnchor","activeSection","getActiveSection","headerOffset","isHeaderShown","getHeaderHeight","getAnchorBarHeight","currentPosition","i","length","getElementPosition","index","section","anchorBarOffset","getBoundingClientRect","top","anchorElements","setAttribute","hasOverflow","scrollIntoView","behavior","inline","removeAttribute","checkForOverflow","anchorBarContainer","width","containerWidth","availableWidth","itemsWidth","reduce","acc","item","handleHeaderShown","handleHeaderHidden","handleCurrentIndexChange","updateButtonStates","goToSectionIndex","componentDidLoad","rootNode","el","getRootNode","ShadowRoot","initializeElements","setupObservers","setupEventListeners","disconnectedCallback","cleanupObservers","cleanupEventListeners","setupClickHandlers","addEventListener","removeEventListener","forEach","_a","sectionVisibilityObserver","disconnect","_b","anchorBarStickyObserver","_c","lastSectionObserver","header","document","querySelector","Array","from","children","filter","child","tagName","toLowerCase","map","host","shadowRoot","set","Boolean","IntersectionObserver","_ref","entry","shouldBeSticky","isIntersecting","threshold","rootMargin","observe","lastSection","nextElementSibling","entries","lastSectionEntry","rect","boundingClientRect","anchorBarHeight","bottom","height","zero","arguments","undefined","style","setProperty","get","headerHeight","getScrollDirection","safeZoneOffset","scrollOffset","totalOffset","scrollMarginTop","block","removeProperty","history","pushState","targetSection","currentSection","innerHeight","handleOverflowButtonClick","direction","nextIndex","Math","max","min","isAtStart","isAtEnd","render","overflowButtonLeft","h","key","icon","variant","size","disabled","onClick","overflowButtonRight","class","ref"],"sourceRoot":""}